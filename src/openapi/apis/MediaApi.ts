/* tslint:disable */
/* eslint-disable */
/**
 * imperia-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyMediaResponse,
  DestroyRequest,
  GetModelMediaResponse,
  IndexMediaResponse,
  SetModelMediaRequest,
  SetModelMediaResponse,
  ShowMediaResponse,
  StoreMediaResponse,
  UnauthenticatedResponse,
  UpdateMediaRequest,
  UpdateMediaResponse,
} from '../models';
import {
    DestroyMediaResponseFromJSON,
    DestroyMediaResponseToJSON,
    DestroyRequestFromJSON,
    DestroyRequestToJSON,
    GetModelMediaResponseFromJSON,
    GetModelMediaResponseToJSON,
    IndexMediaResponseFromJSON,
    IndexMediaResponseToJSON,
    SetModelMediaRequestFromJSON,
    SetModelMediaRequestToJSON,
    SetModelMediaResponseFromJSON,
    SetModelMediaResponseToJSON,
    ShowMediaResponseFromJSON,
    ShowMediaResponseToJSON,
    StoreMediaResponseFromJSON,
    StoreMediaResponseToJSON,
    UnauthenticatedResponseFromJSON,
    UnauthenticatedResponseToJSON,
    UpdateMediaRequestFromJSON,
    UpdateMediaRequestToJSON,
    UpdateMediaResponseFromJSON,
    UpdateMediaResponseToJSON,
} from '../models';

export interface DestroyMediaRequest {
    id: number;
    destroyRequest?: DestroyRequest;
}

export interface GetModelMediaRequest {
    modelId: number;
    modelType: string;
}

export interface IndexMediaRequest {
    pageSize?: number;
    pageNumber?: number;
    filterName?: string;
    filterExtension?: string;
    filterDisk?: string;
    filterFolder?: string;
}

export interface SetModelMediaOperationRequest {
    setModelMediaRequest?: SetModelMediaRequest;
}

export interface ShowMediaRequest {
    id: number;
}

export interface StoreMediaRequest {
    file?: Blob;
    name?: string;
    title?: string | null;
    description?: string | null;
    disk?: StoreMediaDiskEnum;
    folder?: string;
    metadata?: object | null;
}

export interface UpdateMediaOperationRequest {
    id: number;
    updateMediaRequest: UpdateMediaRequest;
}

/**
 * 
 */
export class MediaApi extends runtime.BaseAPI {

    /**
     * Delete media.
     */
    async destroyMediaRaw(requestParameters: DestroyMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyMediaResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyMedia.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/media/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: DestroyRequestToJSON(requestParameters.destroyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyMediaResponseFromJSON(jsonValue));
    }

    /**
     * Delete media.
     */
    async destroyMedia(requestParameters: DestroyMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyMediaResponse> {
        const response = await this.destroyMediaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get model\'s media.
     */
    async getModelMediaRaw(requestParameters: GetModelMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetModelMediaResponse>> {
        if (requestParameters.modelId === null || requestParameters.modelId === undefined) {
            throw new runtime.RequiredError('modelId','Required parameter requestParameters.modelId was null or undefined when calling getModelMedia.');
        }

        if (requestParameters.modelType === null || requestParameters.modelType === undefined) {
            throw new runtime.RequiredError('modelType','Required parameter requestParameters.modelType was null or undefined when calling getModelMedia.');
        }

        const queryParameters: any = {};

        if (requestParameters.modelId !== undefined) {
            queryParameters['model_id'] = requestParameters.modelId;
        }

        if (requestParameters.modelType !== undefined) {
            queryParameters['model_type'] = requestParameters.modelType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/model-media`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetModelMediaResponseFromJSON(jsonValue));
    }

    /**
     * Get model\'s media.
     */
    async getModelMedia(requestParameters: GetModelMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetModelMediaResponse> {
        const response = await this.getModelMediaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index media.
     */
    async indexMediaRaw(requestParameters: IndexMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexMediaResponse>> {
        const queryParameters: any = {};

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterExtension !== undefined) {
            queryParameters['filter[extension]'] = requestParameters.filterExtension;
        }

        if (requestParameters.filterDisk !== undefined) {
            queryParameters['filter[disk]'] = requestParameters.filterDisk;
        }

        if (requestParameters.filterFolder !== undefined) {
            queryParameters['filter[folder]'] = requestParameters.filterFolder;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/media`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexMediaResponseFromJSON(jsonValue));
    }

    /**
     * Index media.
     */
    async indexMedia(requestParameters: IndexMediaRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexMediaResponse> {
        const response = await this.indexMediaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set model\'s media.
     */
    async setModelMediaRaw(requestParameters: SetModelMediaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SetModelMediaResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/model-media`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SetModelMediaRequestToJSON(requestParameters.setModelMediaRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SetModelMediaResponseFromJSON(jsonValue));
    }

    /**
     * Set model\'s media.
     */
    async setModelMedia(requestParameters: SetModelMediaOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SetModelMediaResponse> {
        const response = await this.setModelMediaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show media by id.
     */
    async showMediaRaw(requestParameters: ShowMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowMediaResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showMedia.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/media/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowMediaResponseFromJSON(jsonValue));
    }

    /**
     * Show media by id.
     */
    async showMedia(requestParameters: ShowMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowMediaResponse> {
        const response = await this.showMediaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store media.
     */
    async storeMediaRaw(requestParameters: StoreMediaRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMediaResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        if (requestParameters.title !== undefined) {
            formParams.append('title', requestParameters.title as any);
        }

        if (requestParameters.description !== undefined) {
            formParams.append('description', requestParameters.description as any);
        }

        if (requestParameters.disk !== undefined) {
            formParams.append('disk', requestParameters.disk as any);
        }

        if (requestParameters.folder !== undefined) {
            formParams.append('folder', requestParameters.folder as any);
        }

        if (requestParameters.metadata !== undefined) {
            formParams.append('metadata', new Blob([JSON.stringify(requestParameters.metadata)], { type: "application/json", }));
                    }

        const response = await this.request({
            path: `/api/media`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMediaResponseFromJSON(jsonValue));
    }

    /**
     * Store media.
     */
    async storeMedia(requestParameters: StoreMediaRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMediaResponse> {
        const response = await this.storeMediaRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update media.
     */
    async updateMediaRaw(requestParameters: UpdateMediaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMediaResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateMedia.');
        }

        if (requestParameters.updateMediaRequest === null || requestParameters.updateMediaRequest === undefined) {
            throw new runtime.RequiredError('updateMediaRequest','Required parameter requestParameters.updateMediaRequest was null or undefined when calling updateMedia.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/media/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMediaRequestToJSON(requestParameters.updateMediaRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMediaResponseFromJSON(jsonValue));
    }

    /**
     * Update media.
     */
    async updateMedia(requestParameters: UpdateMediaOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMediaResponse> {
        const response = await this.updateMediaRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const StoreMediaDiskEnum = {
    Public: 'public',
    GoogleCloud: 'google-cloud'
} as const;
export type StoreMediaDiskEnum = typeof StoreMediaDiskEnum[keyof typeof StoreMediaDiskEnum];
