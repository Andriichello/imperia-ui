/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexEntryColumnMappingVersionsResponse,
  ShowEntryColumnMappingVersionResponse,
  StoreEntryColumnMappingVersionRequest,
  StoreEntryColumnMappingVersionResponse,
  StoreMultipleEntryColumnMappingVersions200Response,
  StoreMultipleEntryColumnMappingVersionsRequest,
  UpdateEntryColumnMappingVersionRequest,
  UpdateEntryColumnMappingVersionResponse,
  UpdateMultipleEntryColumnMappingVersions200Response,
  UpdateMultipleEntryColumnMappingVersionsRequest,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexEntryColumnMappingVersionsResponseFromJSON,
    IndexEntryColumnMappingVersionsResponseToJSON,
    ShowEntryColumnMappingVersionResponseFromJSON,
    ShowEntryColumnMappingVersionResponseToJSON,
    StoreEntryColumnMappingVersionRequestFromJSON,
    StoreEntryColumnMappingVersionRequestToJSON,
    StoreEntryColumnMappingVersionResponseFromJSON,
    StoreEntryColumnMappingVersionResponseToJSON,
    StoreMultipleEntryColumnMappingVersions200ResponseFromJSON,
    StoreMultipleEntryColumnMappingVersions200ResponseToJSON,
    StoreMultipleEntryColumnMappingVersionsRequestFromJSON,
    StoreMultipleEntryColumnMappingVersionsRequestToJSON,
    UpdateEntryColumnMappingVersionRequestFromJSON,
    UpdateEntryColumnMappingVersionRequestToJSON,
    UpdateEntryColumnMappingVersionResponseFromJSON,
    UpdateEntryColumnMappingVersionResponseToJSON,
    UpdateMultipleEntryColumnMappingVersions200ResponseFromJSON,
    UpdateMultipleEntryColumnMappingVersions200ResponseToJSON,
    UpdateMultipleEntryColumnMappingVersionsRequestFromJSON,
    UpdateMultipleEntryColumnMappingVersionsRequestToJSON,
} from '../models';

export interface DestroyEntryColumnMappingVersionRequest {
    id: number;
}

export interface ExportEntryColumnMappingVersionsRequest {
    format: ExportEntryColumnMappingVersionsFormatEnum;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterSurveyTypeId?: string;
    filterName?: string;
    filterDescription?: string;
    filterActiveFrom?: string;
    filterActiveUntil?: string;
}

export interface IndexEntryColumnMappingVersionsRequest {
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterSurveyTypeId?: string;
    filterName?: string;
    filterDescription?: string;
    filterActiveFrom?: string;
    filterActiveUntil?: string;
}

export interface ShowEntryColumnMappingVersionRequest {
    id: number;
    includes?: string;
}

export interface StoreEntryColumnMappingVersionOperationRequest {
    storeEntryColumnMappingVersionRequest: StoreEntryColumnMappingVersionRequest;
}

export interface StoreMultipleEntryColumnMappingVersionsOperationRequest {
    storeMultipleEntryColumnMappingVersionsRequest: StoreMultipleEntryColumnMappingVersionsRequest;
}

export interface UpdateEntryColumnMappingVersionOperationRequest {
    id: number;
    updateEntryColumnMappingVersionRequest: UpdateEntryColumnMappingVersionRequest;
}

export interface UpdateMultipleEntryColumnMappingVersionsOperationRequest {
    updateMultipleEntryColumnMappingVersionsRequest: UpdateMultipleEntryColumnMappingVersionsRequest;
}

/**
 * 
 */
export class EnumEntryColumnMappingVersionsApi extends runtime.BaseAPI {

    /**
     * Delete entry column mapping version.
     */
    async destroyEntryColumnMappingVersionRaw(requestParameters: DestroyEntryColumnMappingVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyEntryColumnMappingVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/versions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete entry column mapping version.
     */
    async destroyEntryColumnMappingVersion(requestParameters: DestroyEntryColumnMappingVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyEntryColumnMappingVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export entry column mapping versions in a selected format (csv, json, parquet).
     */
    async exportEntryColumnMappingVersionsRaw(requestParameters: ExportEntryColumnMappingVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportEntryColumnMappingVersions.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterDescription !== undefined) {
            queryParameters['filter[description]'] = requestParameters.filterDescription;
        }

        if (requestParameters.filterActiveFrom !== undefined) {
            queryParameters['filter[active_from]'] = requestParameters.filterActiveFrom;
        }

        if (requestParameters.filterActiveUntil !== undefined) {
            queryParameters['filter[active_until]'] = requestParameters.filterActiveUntil;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/versions/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export entry column mapping versions in a selected format (csv, json, parquet).
     */
    async exportEntryColumnMappingVersions(requestParameters: ExportEntryColumnMappingVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportEntryColumnMappingVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index entry column mapping versions.
     */
    async indexEntryColumnMappingVersionsRaw(requestParameters: IndexEntryColumnMappingVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexEntryColumnMappingVersionsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterDescription !== undefined) {
            queryParameters['filter[description]'] = requestParameters.filterDescription;
        }

        if (requestParameters.filterActiveFrom !== undefined) {
            queryParameters['filter[active_from]'] = requestParameters.filterActiveFrom;
        }

        if (requestParameters.filterActiveUntil !== undefined) {
            queryParameters['filter[active_until]'] = requestParameters.filterActiveUntil;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/versions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexEntryColumnMappingVersionsResponseFromJSON(jsonValue));
    }

    /**
     * Index entry column mapping versions.
     */
    async indexEntryColumnMappingVersions(requestParameters: IndexEntryColumnMappingVersionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexEntryColumnMappingVersionsResponse> {
        const response = await this.indexEntryColumnMappingVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show entry column mapping version by id.
     */
    async showEntryColumnMappingVersionRaw(requestParameters: ShowEntryColumnMappingVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowEntryColumnMappingVersionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showEntryColumnMappingVersion.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/versions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowEntryColumnMappingVersionResponseFromJSON(jsonValue));
    }

    /**
     * Show entry column mapping version by id.
     */
    async showEntryColumnMappingVersion(requestParameters: ShowEntryColumnMappingVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowEntryColumnMappingVersionResponse> {
        const response = await this.showEntryColumnMappingVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store entry column mapping version.
     */
    async storeEntryColumnMappingVersionRaw(requestParameters: StoreEntryColumnMappingVersionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreEntryColumnMappingVersionResponse>> {
        if (requestParameters.storeEntryColumnMappingVersionRequest === null || requestParameters.storeEntryColumnMappingVersionRequest === undefined) {
            throw new runtime.RequiredError('storeEntryColumnMappingVersionRequest','Required parameter requestParameters.storeEntryColumnMappingVersionRequest was null or undefined when calling storeEntryColumnMappingVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/versions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreEntryColumnMappingVersionRequestToJSON(requestParameters.storeEntryColumnMappingVersionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreEntryColumnMappingVersionResponseFromJSON(jsonValue));
    }

    /**
     * Store entry column mapping version.
     */
    async storeEntryColumnMappingVersion(requestParameters: StoreEntryColumnMappingVersionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreEntryColumnMappingVersionResponse> {
        const response = await this.storeEntryColumnMappingVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple entry column mapping versions.
     */
    async storeMultipleEntryColumnMappingVersionsRaw(requestParameters: StoreMultipleEntryColumnMappingVersionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleEntryColumnMappingVersions200Response>> {
        if (requestParameters.storeMultipleEntryColumnMappingVersionsRequest === null || requestParameters.storeMultipleEntryColumnMappingVersionsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleEntryColumnMappingVersionsRequest','Required parameter requestParameters.storeMultipleEntryColumnMappingVersionsRequest was null or undefined when calling storeMultipleEntryColumnMappingVersions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/versions/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleEntryColumnMappingVersionsRequestToJSON(requestParameters.storeMultipleEntryColumnMappingVersionsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleEntryColumnMappingVersions200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple entry column mapping versions.
     */
    async storeMultipleEntryColumnMappingVersions(requestParameters: StoreMultipleEntryColumnMappingVersionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleEntryColumnMappingVersions200Response> {
        const response = await this.storeMultipleEntryColumnMappingVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update entry column mapping version.
     */
    async updateEntryColumnMappingVersionRaw(requestParameters: UpdateEntryColumnMappingVersionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateEntryColumnMappingVersionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateEntryColumnMappingVersion.');
        }

        if (requestParameters.updateEntryColumnMappingVersionRequest === null || requestParameters.updateEntryColumnMappingVersionRequest === undefined) {
            throw new runtime.RequiredError('updateEntryColumnMappingVersionRequest','Required parameter requestParameters.updateEntryColumnMappingVersionRequest was null or undefined when calling updateEntryColumnMappingVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/versions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEntryColumnMappingVersionRequestToJSON(requestParameters.updateEntryColumnMappingVersionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateEntryColumnMappingVersionResponseFromJSON(jsonValue));
    }

    /**
     * Update entry column mapping version.
     */
    async updateEntryColumnMappingVersion(requestParameters: UpdateEntryColumnMappingVersionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateEntryColumnMappingVersionResponse> {
        const response = await this.updateEntryColumnMappingVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple entry column mapping versions.
     */
    async updateMultipleEntryColumnMappingVersionsRaw(requestParameters: UpdateMultipleEntryColumnMappingVersionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleEntryColumnMappingVersions200Response>> {
        if (requestParameters.updateMultipleEntryColumnMappingVersionsRequest === null || requestParameters.updateMultipleEntryColumnMappingVersionsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleEntryColumnMappingVersionsRequest','Required parameter requestParameters.updateMultipleEntryColumnMappingVersionsRequest was null or undefined when calling updateMultipleEntryColumnMappingVersions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/versions/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleEntryColumnMappingVersionsRequestToJSON(requestParameters.updateMultipleEntryColumnMappingVersionsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleEntryColumnMappingVersions200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple entry column mapping versions.
     */
    async updateMultipleEntryColumnMappingVersions(requestParameters: UpdateMultipleEntryColumnMappingVersionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleEntryColumnMappingVersions200Response> {
        const response = await this.updateMultipleEntryColumnMappingVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportEntryColumnMappingVersionsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportEntryColumnMappingVersionsFormatEnum = typeof ExportEntryColumnMappingVersionsFormatEnum[keyof typeof ExportEntryColumnMappingVersionsFormatEnum];
