/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexCovarBinsResponse,
  ShowCovarBinResponse,
  StoreCovarBinRequest,
  StoreCovarBinResponse,
  StoreMultipleCovarBins200Response,
  StoreMultipleCovarBinsRequest,
  UpdateCovarBinRequest,
  UpdateCovarBinResponse,
  UpdateMultipleCovarBins200Response,
  UpdateMultipleCovarBinsRequest,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexCovarBinsResponseFromJSON,
    IndexCovarBinsResponseToJSON,
    ShowCovarBinResponseFromJSON,
    ShowCovarBinResponseToJSON,
    StoreCovarBinRequestFromJSON,
    StoreCovarBinRequestToJSON,
    StoreCovarBinResponseFromJSON,
    StoreCovarBinResponseToJSON,
    StoreMultipleCovarBins200ResponseFromJSON,
    StoreMultipleCovarBins200ResponseToJSON,
    StoreMultipleCovarBinsRequestFromJSON,
    StoreMultipleCovarBinsRequestToJSON,
    UpdateCovarBinRequestFromJSON,
    UpdateCovarBinRequestToJSON,
    UpdateCovarBinResponseFromJSON,
    UpdateCovarBinResponseToJSON,
    UpdateMultipleCovarBins200ResponseFromJSON,
    UpdateMultipleCovarBins200ResponseToJSON,
    UpdateMultipleCovarBinsRequestFromJSON,
    UpdateMultipleCovarBinsRequestToJSON,
} from '../models';

export interface DestroyCovarBinRequest {
    id: number;
}

export interface ExportCovarBinsRequest {
    format: ExportCovarBinsFormatEnum;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterCovarId?: string;
    filterModelId?: string;
    filterSurveyTypeId?: string;
    filterMin?: string;
    filterMax?: string;
    filterValue?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface IndexCovarBinsRequest {
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterCovarId?: string;
    filterModelId?: string;
    filterSurveyTypeId?: string;
    filterMin?: string;
    filterMax?: string;
    filterValue?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface ShowCovarBinRequest {
    id: number;
    includes?: string;
}

export interface StoreCovarBinOperationRequest {
    storeCovarBinRequest: StoreCovarBinRequest;
}

export interface StoreMultipleCovarBinsOperationRequest {
    storeMultipleCovarBinsRequest: StoreMultipleCovarBinsRequest;
}

export interface UpdateCovarBinOperationRequest {
    id: number;
    updateCovarBinRequest: UpdateCovarBinRequest;
}

export interface UpdateMultipleCovarBinsOperationRequest {
    updateMultipleCovarBinsRequest: UpdateMultipleCovarBinsRequest;
}

/**
 * 
 */
export class ModelCovarBinsApi extends runtime.BaseAPI {

    /**
     * Delete covar bin.
     */
    async destroyCovarBinRaw(requestParameters: DestroyCovarBinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyCovarBin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/bins/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete covar bin.
     */
    async destroyCovarBin(requestParameters: DestroyCovarBinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyCovarBinRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export covar bins in a selected format (csv, json, parquet).
     */
    async exportCovarBinsRaw(requestParameters: ExportCovarBinsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportCovarBins.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterCovarId !== undefined) {
            queryParameters['filter[covar_id]'] = requestParameters.filterCovarId;
        }

        if (requestParameters.filterModelId !== undefined) {
            queryParameters['filter[model_id]'] = requestParameters.filterModelId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterMin !== undefined) {
            queryParameters['filter[min]'] = requestParameters.filterMin;
        }

        if (requestParameters.filterMax !== undefined) {
            queryParameters['filter[max]'] = requestParameters.filterMax;
        }

        if (requestParameters.filterValue !== undefined) {
            queryParameters['filter[value]'] = requestParameters.filterValue;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/bins/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export covar bins in a selected format (csv, json, parquet).
     */
    async exportCovarBins(requestParameters: ExportCovarBinsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportCovarBinsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index covar bins.
     */
    async indexCovarBinsRaw(requestParameters: IndexCovarBinsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexCovarBinsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterCovarId !== undefined) {
            queryParameters['filter[covar_id]'] = requestParameters.filterCovarId;
        }

        if (requestParameters.filterModelId !== undefined) {
            queryParameters['filter[model_id]'] = requestParameters.filterModelId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterMin !== undefined) {
            queryParameters['filter[min]'] = requestParameters.filterMin;
        }

        if (requestParameters.filterMax !== undefined) {
            queryParameters['filter[max]'] = requestParameters.filterMax;
        }

        if (requestParameters.filterValue !== undefined) {
            queryParameters['filter[value]'] = requestParameters.filterValue;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/bins`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexCovarBinsResponseFromJSON(jsonValue));
    }

    /**
     * Index covar bins.
     */
    async indexCovarBins(requestParameters: IndexCovarBinsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexCovarBinsResponse> {
        const response = await this.indexCovarBinsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show covar bin by id.
     */
    async showCovarBinRaw(requestParameters: ShowCovarBinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowCovarBinResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showCovarBin.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/bins/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowCovarBinResponseFromJSON(jsonValue));
    }

    /**
     * Show covar bin by id.
     */
    async showCovarBin(requestParameters: ShowCovarBinRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowCovarBinResponse> {
        const response = await this.showCovarBinRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store covar bin.
     */
    async storeCovarBinRaw(requestParameters: StoreCovarBinOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreCovarBinResponse>> {
        if (requestParameters.storeCovarBinRequest === null || requestParameters.storeCovarBinRequest === undefined) {
            throw new runtime.RequiredError('storeCovarBinRequest','Required parameter requestParameters.storeCovarBinRequest was null or undefined when calling storeCovarBin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/bins`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreCovarBinRequestToJSON(requestParameters.storeCovarBinRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreCovarBinResponseFromJSON(jsonValue));
    }

    /**
     * Store covar bin.
     */
    async storeCovarBin(requestParameters: StoreCovarBinOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreCovarBinResponse> {
        const response = await this.storeCovarBinRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple covar bins.
     */
    async storeMultipleCovarBinsRaw(requestParameters: StoreMultipleCovarBinsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleCovarBins200Response>> {
        if (requestParameters.storeMultipleCovarBinsRequest === null || requestParameters.storeMultipleCovarBinsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleCovarBinsRequest','Required parameter requestParameters.storeMultipleCovarBinsRequest was null or undefined when calling storeMultipleCovarBins.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/bins/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleCovarBinsRequestToJSON(requestParameters.storeMultipleCovarBinsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleCovarBins200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple covar bins.
     */
    async storeMultipleCovarBins(requestParameters: StoreMultipleCovarBinsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleCovarBins200Response> {
        const response = await this.storeMultipleCovarBinsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update covar bin.
     */
    async updateCovarBinRaw(requestParameters: UpdateCovarBinOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateCovarBinResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCovarBin.');
        }

        if (requestParameters.updateCovarBinRequest === null || requestParameters.updateCovarBinRequest === undefined) {
            throw new runtime.RequiredError('updateCovarBinRequest','Required parameter requestParameters.updateCovarBinRequest was null or undefined when calling updateCovarBin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/bins/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCovarBinRequestToJSON(requestParameters.updateCovarBinRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateCovarBinResponseFromJSON(jsonValue));
    }

    /**
     * Update covar bin.
     */
    async updateCovarBin(requestParameters: UpdateCovarBinOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateCovarBinResponse> {
        const response = await this.updateCovarBinRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple covar bins.
     */
    async updateMultipleCovarBinsRaw(requestParameters: UpdateMultipleCovarBinsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleCovarBins200Response>> {
        if (requestParameters.updateMultipleCovarBinsRequest === null || requestParameters.updateMultipleCovarBinsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleCovarBinsRequest','Required parameter requestParameters.updateMultipleCovarBinsRequest was null or undefined when calling updateMultipleCovarBins.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/bins/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleCovarBinsRequestToJSON(requestParameters.updateMultipleCovarBinsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleCovarBins200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple covar bins.
     */
    async updateMultipleCovarBins(requestParameters: UpdateMultipleCovarBinsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleCovarBins200Response> {
        const response = await this.updateMultipleCovarBinsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportCovarBinsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportCovarBinsFormatEnum = typeof ExportCovarBinsFormatEnum[keyof typeof ExportCovarBinsFormatEnum];
