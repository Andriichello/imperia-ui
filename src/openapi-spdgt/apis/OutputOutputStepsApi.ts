/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexOutputStepsResponse,
  ShowOutputStepResponse,
  StoreMultipleOutputSteps200Response,
  StoreMultipleOutputStepsRequest,
  StoreOutputStepRequest,
  StoreOutputStepResponse,
  UpdateMultipleOutputSteps200Response,
  UpdateMultipleOutputStepsRequest,
  UpdateOutputStepRequest,
  UpdateOutputStepResponse,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexOutputStepsResponseFromJSON,
    IndexOutputStepsResponseToJSON,
    ShowOutputStepResponseFromJSON,
    ShowOutputStepResponseToJSON,
    StoreMultipleOutputSteps200ResponseFromJSON,
    StoreMultipleOutputSteps200ResponseToJSON,
    StoreMultipleOutputStepsRequestFromJSON,
    StoreMultipleOutputStepsRequestToJSON,
    StoreOutputStepRequestFromJSON,
    StoreOutputStepRequestToJSON,
    StoreOutputStepResponseFromJSON,
    StoreOutputStepResponseToJSON,
    UpdateMultipleOutputSteps200ResponseFromJSON,
    UpdateMultipleOutputSteps200ResponseToJSON,
    UpdateMultipleOutputStepsRequestFromJSON,
    UpdateMultipleOutputStepsRequestToJSON,
    UpdateOutputStepRequestFromJSON,
    UpdateOutputStepRequestToJSON,
    UpdateOutputStepResponseFromJSON,
    UpdateOutputStepResponseToJSON,
} from '../models';

export interface DestroyOutputStepRequest {
    id: number;
}

export interface ExportOutputStepsRequest {
    format: ExportOutputStepsFormatEnum;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterOutputId?: string;
    filterNumber?: string;
    filterStatus?: string;
    filterMetadata?: string;
    filterStartedAt?: string;
    filterFinishedAt?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface IndexOutputStepsRequest {
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterOutputId?: string;
    filterNumber?: string;
    filterStatus?: string;
    filterMetadata?: string;
    filterStartedAt?: string;
    filterFinishedAt?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface ShowOutputStepRequest {
    id: number;
    includes?: string;
}

export interface StoreMultipleOutputStepsOperationRequest {
    storeMultipleOutputStepsRequest: StoreMultipleOutputStepsRequest;
}

export interface StoreOutputStepOperationRequest {
    storeOutputStepRequest: StoreOutputStepRequest;
}

export interface UpdateMultipleOutputStepsOperationRequest {
    updateMultipleOutputStepsRequest: UpdateMultipleOutputStepsRequest;
}

export interface UpdateOutputStepOperationRequest {
    id: number;
    updateOutputStepRequest: UpdateOutputStepRequest;
}

/**
 * 
 */
export class OutputOutputStepsApi extends runtime.BaseAPI {

    /**
     * Delete model output step.
     */
    async destroyOutputStepRaw(requestParameters: DestroyOutputStepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyOutputStep.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/output-steps/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete model output step.
     */
    async destroyOutputStep(requestParameters: DestroyOutputStepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyOutputStepRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export model output steps in a selected format (csv, json, parquet).
     */
    async exportOutputStepsRaw(requestParameters: ExportOutputStepsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportOutputSteps.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterOutputId !== undefined) {
            queryParameters['filter[output_id]'] = requestParameters.filterOutputId;
        }

        if (requestParameters.filterNumber !== undefined) {
            queryParameters['filter[number]'] = requestParameters.filterNumber;
        }

        if (requestParameters.filterStatus !== undefined) {
            queryParameters['filter[status]'] = requestParameters.filterStatus;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterStartedAt !== undefined) {
            queryParameters['filter[started_at]'] = requestParameters.filterStartedAt;
        }

        if (requestParameters.filterFinishedAt !== undefined) {
            queryParameters['filter[finished_at]'] = requestParameters.filterFinishedAt;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/output-steps/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export model output steps in a selected format (csv, json, parquet).
     */
    async exportOutputSteps(requestParameters: ExportOutputStepsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportOutputStepsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index model output steps.
     */
    async indexOutputStepsRaw(requestParameters: IndexOutputStepsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexOutputStepsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterOutputId !== undefined) {
            queryParameters['filter[output_id]'] = requestParameters.filterOutputId;
        }

        if (requestParameters.filterNumber !== undefined) {
            queryParameters['filter[number]'] = requestParameters.filterNumber;
        }

        if (requestParameters.filterStatus !== undefined) {
            queryParameters['filter[status]'] = requestParameters.filterStatus;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterStartedAt !== undefined) {
            queryParameters['filter[started_at]'] = requestParameters.filterStartedAt;
        }

        if (requestParameters.filterFinishedAt !== undefined) {
            queryParameters['filter[finished_at]'] = requestParameters.filterFinishedAt;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/output-steps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexOutputStepsResponseFromJSON(jsonValue));
    }

    /**
     * Index model output steps.
     */
    async indexOutputSteps(requestParameters: IndexOutputStepsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexOutputStepsResponse> {
        const response = await this.indexOutputStepsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show model output step by id.
     */
    async showOutputStepRaw(requestParameters: ShowOutputStepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowOutputStepResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showOutputStep.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/output-steps/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowOutputStepResponseFromJSON(jsonValue));
    }

    /**
     * Show model output step by id.
     */
    async showOutputStep(requestParameters: ShowOutputStepRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowOutputStepResponse> {
        const response = await this.showOutputStepRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple output steps.
     */
    async storeMultipleOutputStepsRaw(requestParameters: StoreMultipleOutputStepsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleOutputSteps200Response>> {
        if (requestParameters.storeMultipleOutputStepsRequest === null || requestParameters.storeMultipleOutputStepsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleOutputStepsRequest','Required parameter requestParameters.storeMultipleOutputStepsRequest was null or undefined when calling storeMultipleOutputSteps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/output-steps/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleOutputStepsRequestToJSON(requestParameters.storeMultipleOutputStepsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleOutputSteps200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple output steps.
     */
    async storeMultipleOutputSteps(requestParameters: StoreMultipleOutputStepsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleOutputSteps200Response> {
        const response = await this.storeMultipleOutputStepsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store model output step.
     */
    async storeOutputStepRaw(requestParameters: StoreOutputStepOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreOutputStepResponse>> {
        if (requestParameters.storeOutputStepRequest === null || requestParameters.storeOutputStepRequest === undefined) {
            throw new runtime.RequiredError('storeOutputStepRequest','Required parameter requestParameters.storeOutputStepRequest was null or undefined when calling storeOutputStep.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/output-steps`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreOutputStepRequestToJSON(requestParameters.storeOutputStepRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreOutputStepResponseFromJSON(jsonValue));
    }

    /**
     * Store model output step.
     */
    async storeOutputStep(requestParameters: StoreOutputStepOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreOutputStepResponse> {
        const response = await this.storeOutputStepRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple outputs.
     */
    async updateMultipleOutputStepsRaw(requestParameters: UpdateMultipleOutputStepsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleOutputSteps200Response>> {
        if (requestParameters.updateMultipleOutputStepsRequest === null || requestParameters.updateMultipleOutputStepsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleOutputStepsRequest','Required parameter requestParameters.updateMultipleOutputStepsRequest was null or undefined when calling updateMultipleOutputSteps.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/output-steps/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleOutputStepsRequestToJSON(requestParameters.updateMultipleOutputStepsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleOutputSteps200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple outputs.
     */
    async updateMultipleOutputSteps(requestParameters: UpdateMultipleOutputStepsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleOutputSteps200Response> {
        const response = await this.updateMultipleOutputStepsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update model output step.
     */
    async updateOutputStepRaw(requestParameters: UpdateOutputStepOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateOutputStepResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateOutputStep.');
        }

        if (requestParameters.updateOutputStepRequest === null || requestParameters.updateOutputStepRequest === undefined) {
            throw new runtime.RequiredError('updateOutputStepRequest','Required parameter requestParameters.updateOutputStepRequest was null or undefined when calling updateOutputStep.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/output-steps/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateOutputStepRequestToJSON(requestParameters.updateOutputStepRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateOutputStepResponseFromJSON(jsonValue));
    }

    /**
     * Update model output step.
     */
    async updateOutputStep(requestParameters: UpdateOutputStepOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateOutputStepResponse> {
        const response = await this.updateOutputStepRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportOutputStepsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportOutputStepsFormatEnum = typeof ExportOutputStepsFormatEnum[keyof typeof ExportOutputStepsFormatEnum];
