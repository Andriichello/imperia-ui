/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexColumnMappingsResponse,
  ShowColumnMappingResponse,
  StoreColumnMappingRequest,
  StoreColumnMappingResponse,
  StoreMultipleColumnMappings200Response,
  StoreMultipleColumnMappingsRequest,
  UpdateColumnMappingRequest,
  UpdateColumnMappingResponse,
  UpdateMultipleColumnMappings200Response,
  UpdateMultipleColumnMappingsRequest,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexColumnMappingsResponseFromJSON,
    IndexColumnMappingsResponseToJSON,
    ShowColumnMappingResponseFromJSON,
    ShowColumnMappingResponseToJSON,
    StoreColumnMappingRequestFromJSON,
    StoreColumnMappingRequestToJSON,
    StoreColumnMappingResponseFromJSON,
    StoreColumnMappingResponseToJSON,
    StoreMultipleColumnMappings200ResponseFromJSON,
    StoreMultipleColumnMappings200ResponseToJSON,
    StoreMultipleColumnMappingsRequestFromJSON,
    StoreMultipleColumnMappingsRequestToJSON,
    UpdateColumnMappingRequestFromJSON,
    UpdateColumnMappingRequestToJSON,
    UpdateColumnMappingResponseFromJSON,
    UpdateColumnMappingResponseToJSON,
    UpdateMultipleColumnMappings200ResponseFromJSON,
    UpdateMultipleColumnMappings200ResponseToJSON,
    UpdateMultipleColumnMappingsRequestFromJSON,
    UpdateMultipleColumnMappingsRequestToJSON,
} from '../models';

export interface DestroyColumnMappingRequest {
    id: number;
}

export interface ExportColumnMappingsRequest {
    format: ExportColumnMappingsFormatEnum;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterSurveyTypeId?: string;
    filterName?: string;
    filterDisplay?: string;
}

export interface IndexColumnMappingsRequest {
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterSurveyTypeId?: string;
    filterName?: string;
    filterDisplay?: string;
}

export interface ShowColumnMappingRequest {
    id: number;
    includes?: string;
}

export interface StoreColumnMappingOperationRequest {
    storeColumnMappingRequest: StoreColumnMappingRequest;
}

export interface StoreMultipleColumnMappingsOperationRequest {
    storeMultipleColumnMappingsRequest: StoreMultipleColumnMappingsRequest;
}

export interface UpdateColumnMappingOperationRequest {
    id: number;
    updateColumnMappingRequest: UpdateColumnMappingRequest;
}

export interface UpdateMultipleColumnMappingsOperationRequest {
    updateMultipleColumnMappingsRequest: UpdateMultipleColumnMappingsRequest;
}

/**
 * 
 */
export class EnumSurveyColumnMappingsApi extends runtime.BaseAPI {

    /**
     * Delete column mapping.
     */
    async destroyColumnMappingRaw(requestParameters: DestroyColumnMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyColumnMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/column-mappings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete column mapping.
     */
    async destroyColumnMapping(requestParameters: DestroyColumnMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyColumnMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export column mappings in a selected format (csv, json, parquet).
     */
    async exportColumnMappingsRaw(requestParameters: ExportColumnMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportColumnMappings.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterDisplay !== undefined) {
            queryParameters['filter[display]'] = requestParameters.filterDisplay;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/column-mappings/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export column mappings in a selected format (csv, json, parquet).
     */
    async exportColumnMappings(requestParameters: ExportColumnMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportColumnMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index column mappings.
     */
    async indexColumnMappingsRaw(requestParameters: IndexColumnMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexColumnMappingsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterDisplay !== undefined) {
            queryParameters['filter[display]'] = requestParameters.filterDisplay;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/column-mappings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexColumnMappingsResponseFromJSON(jsonValue));
    }

    /**
     * Index column mappings.
     */
    async indexColumnMappings(requestParameters: IndexColumnMappingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexColumnMappingsResponse> {
        const response = await this.indexColumnMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show column mapping by id.
     */
    async showColumnMappingRaw(requestParameters: ShowColumnMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowColumnMappingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showColumnMapping.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/column-mappings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowColumnMappingResponseFromJSON(jsonValue));
    }

    /**
     * Show column mapping by id.
     */
    async showColumnMapping(requestParameters: ShowColumnMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowColumnMappingResponse> {
        const response = await this.showColumnMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store column mapping.
     */
    async storeColumnMappingRaw(requestParameters: StoreColumnMappingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreColumnMappingResponse>> {
        if (requestParameters.storeColumnMappingRequest === null || requestParameters.storeColumnMappingRequest === undefined) {
            throw new runtime.RequiredError('storeColumnMappingRequest','Required parameter requestParameters.storeColumnMappingRequest was null or undefined when calling storeColumnMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/column-mappings`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreColumnMappingRequestToJSON(requestParameters.storeColumnMappingRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreColumnMappingResponseFromJSON(jsonValue));
    }

    /**
     * Store column mapping.
     */
    async storeColumnMapping(requestParameters: StoreColumnMappingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreColumnMappingResponse> {
        const response = await this.storeColumnMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple column mappings.
     */
    async storeMultipleColumnMappingsRaw(requestParameters: StoreMultipleColumnMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleColumnMappings200Response>> {
        if (requestParameters.storeMultipleColumnMappingsRequest === null || requestParameters.storeMultipleColumnMappingsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleColumnMappingsRequest','Required parameter requestParameters.storeMultipleColumnMappingsRequest was null or undefined when calling storeMultipleColumnMappings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/column-mappings/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleColumnMappingsRequestToJSON(requestParameters.storeMultipleColumnMappingsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleColumnMappings200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple column mappings.
     */
    async storeMultipleColumnMappings(requestParameters: StoreMultipleColumnMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleColumnMappings200Response> {
        const response = await this.storeMultipleColumnMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update column mapping.
     */
    async updateColumnMappingRaw(requestParameters: UpdateColumnMappingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateColumnMappingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateColumnMapping.');
        }

        if (requestParameters.updateColumnMappingRequest === null || requestParameters.updateColumnMappingRequest === undefined) {
            throw new runtime.RequiredError('updateColumnMappingRequest','Required parameter requestParameters.updateColumnMappingRequest was null or undefined when calling updateColumnMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/column-mappings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateColumnMappingRequestToJSON(requestParameters.updateColumnMappingRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateColumnMappingResponseFromJSON(jsonValue));
    }

    /**
     * Update column mapping.
     */
    async updateColumnMapping(requestParameters: UpdateColumnMappingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateColumnMappingResponse> {
        const response = await this.updateColumnMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple column mappings.
     */
    async updateMultipleColumnMappingsRaw(requestParameters: UpdateMultipleColumnMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleColumnMappings200Response>> {
        if (requestParameters.updateMultipleColumnMappingsRequest === null || requestParameters.updateMultipleColumnMappingsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleColumnMappingsRequest','Required parameter requestParameters.updateMultipleColumnMappingsRequest was null or undefined when calling updateMultipleColumnMappings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/column-mappings/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleColumnMappingsRequestToJSON(requestParameters.updateMultipleColumnMappingsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleColumnMappings200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple column mappings.
     */
    async updateMultipleColumnMappings(requestParameters: UpdateMultipleColumnMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleColumnMappings200Response> {
        const response = await this.updateMultipleColumnMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportColumnMappingsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportColumnMappingsFormatEnum = typeof ExportColumnMappingsFormatEnum[keyof typeof ExportColumnMappingsFormatEnum];
