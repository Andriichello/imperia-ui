/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexRecipesResponse,
  ShowRecipeResponse,
  StoreMultipleRecipes200Response,
  StoreMultipleRecipesRequest,
  StoreRecipeRequest,
  StoreRecipeResponse,
  UpdateMultipleRecipes200Response,
  UpdateMultipleRecipesRequest,
  UpdateRecipeRequest,
  UpdateRecipeResponse,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexRecipesResponseFromJSON,
    IndexRecipesResponseToJSON,
    ShowRecipeResponseFromJSON,
    ShowRecipeResponseToJSON,
    StoreMultipleRecipes200ResponseFromJSON,
    StoreMultipleRecipes200ResponseToJSON,
    StoreMultipleRecipesRequestFromJSON,
    StoreMultipleRecipesRequestToJSON,
    StoreRecipeRequestFromJSON,
    StoreRecipeRequestToJSON,
    StoreRecipeResponseFromJSON,
    StoreRecipeResponseToJSON,
    UpdateMultipleRecipes200ResponseFromJSON,
    UpdateMultipleRecipes200ResponseToJSON,
    UpdateMultipleRecipesRequestFromJSON,
    UpdateMultipleRecipesRequestToJSON,
    UpdateRecipeRequestFromJSON,
    UpdateRecipeRequestToJSON,
    UpdateRecipeResponseFromJSON,
    UpdateRecipeResponseToJSON,
} from '../models';

export interface DestroyRecipeRequest {
    id: number;
}

export interface ExportRecipesRequest {
    format: ExportRecipesFormatEnum;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterType?: string;
    filterProjectId?: string;
    filterModel?: string;
    filterSpecies?: string;
    filterSurveyType?: string;
    filterAnalysisUnit?: string;
    filterManagementUnit?: string;
    filterYear?: string;
    filterKeywords?: string;
    filterMetadata?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface IndexRecipesRequest {
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterType?: string;
    filterProjectId?: string;
    filterModel?: string;
    filterSpecies?: string;
    filterSurveyType?: string;
    filterAnalysisUnit?: string;
    filterManagementUnit?: string;
    filterYear?: string;
    filterKeywords?: string;
    filterMetadata?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface ShowRecipeRequest {
    id: number;
    includes?: string;
}

export interface StoreMultipleRecipesOperationRequest {
    storeMultipleRecipesRequest: StoreMultipleRecipesRequest;
}

export interface StoreRecipeOperationRequest {
    storeRecipeRequest: StoreRecipeRequest;
}

export interface UpdateMultipleRecipesOperationRequest {
    updateMultipleRecipesRequest: UpdateMultipleRecipesRequest;
}

export interface UpdateRecipeOperationRequest {
    id: number;
    updateRecipeRequest: UpdateRecipeRequest;
}

/**
 * 
 */
export class RecipesApi extends runtime.BaseAPI {

    /**
     * Delete recipe.
     */
    async destroyRecipeRaw(requestParameters: DestroyRecipeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyRecipe.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/recipes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete recipe.
     */
    async destroyRecipe(requestParameters: DestroyRecipeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyRecipeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export recipes in a selected format (csv, json, parquet).
     */
    async exportRecipesRaw(requestParameters: ExportRecipesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportRecipes.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterType !== undefined) {
            queryParameters['filter[type]'] = requestParameters.filterType;
        }

        if (requestParameters.filterProjectId !== undefined) {
            queryParameters['filter[project_id]'] = requestParameters.filterProjectId;
        }

        if (requestParameters.filterModel !== undefined) {
            queryParameters['filter[model]'] = requestParameters.filterModel;
        }

        if (requestParameters.filterSpecies !== undefined) {
            queryParameters['filter[species]'] = requestParameters.filterSpecies;
        }

        if (requestParameters.filterSurveyType !== undefined) {
            queryParameters['filter[survey_type]'] = requestParameters.filterSurveyType;
        }

        if (requestParameters.filterAnalysisUnit !== undefined) {
            queryParameters['filter[analysis_unit]'] = requestParameters.filterAnalysisUnit;
        }

        if (requestParameters.filterManagementUnit !== undefined) {
            queryParameters['filter[management_unit]'] = requestParameters.filterManagementUnit;
        }

        if (requestParameters.filterYear !== undefined) {
            queryParameters['filter[year]'] = requestParameters.filterYear;
        }

        if (requestParameters.filterKeywords !== undefined) {
            queryParameters['filter[keywords]'] = requestParameters.filterKeywords;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/recipes/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export recipes in a selected format (csv, json, parquet).
     */
    async exportRecipes(requestParameters: ExportRecipesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportRecipesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index recipes.
     */
    async indexRecipesRaw(requestParameters: IndexRecipesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexRecipesResponse>> {
        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterType !== undefined) {
            queryParameters['filter[type]'] = requestParameters.filterType;
        }

        if (requestParameters.filterProjectId !== undefined) {
            queryParameters['filter[project_id]'] = requestParameters.filterProjectId;
        }

        if (requestParameters.filterModel !== undefined) {
            queryParameters['filter[model]'] = requestParameters.filterModel;
        }

        if (requestParameters.filterSpecies !== undefined) {
            queryParameters['filter[species]'] = requestParameters.filterSpecies;
        }

        if (requestParameters.filterSurveyType !== undefined) {
            queryParameters['filter[survey_type]'] = requestParameters.filterSurveyType;
        }

        if (requestParameters.filterAnalysisUnit !== undefined) {
            queryParameters['filter[analysis_unit]'] = requestParameters.filterAnalysisUnit;
        }

        if (requestParameters.filterManagementUnit !== undefined) {
            queryParameters['filter[management_unit]'] = requestParameters.filterManagementUnit;
        }

        if (requestParameters.filterYear !== undefined) {
            queryParameters['filter[year]'] = requestParameters.filterYear;
        }

        if (requestParameters.filterKeywords !== undefined) {
            queryParameters['filter[keywords]'] = requestParameters.filterKeywords;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/recipes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexRecipesResponseFromJSON(jsonValue));
    }

    /**
     * Index recipes.
     */
    async indexRecipes(requestParameters: IndexRecipesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexRecipesResponse> {
        const response = await this.indexRecipesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show recipe by id.
     */
    async showRecipeRaw(requestParameters: ShowRecipeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowRecipeResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showRecipe.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/recipes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowRecipeResponseFromJSON(jsonValue));
    }

    /**
     * Show recipe by id.
     */
    async showRecipe(requestParameters: ShowRecipeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowRecipeResponse> {
        const response = await this.showRecipeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple recipes.
     */
    async storeMultipleRecipesRaw(requestParameters: StoreMultipleRecipesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleRecipes200Response>> {
        if (requestParameters.storeMultipleRecipesRequest === null || requestParameters.storeMultipleRecipesRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleRecipesRequest','Required parameter requestParameters.storeMultipleRecipesRequest was null or undefined when calling storeMultipleRecipes.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/recipes/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleRecipesRequestToJSON(requestParameters.storeMultipleRecipesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleRecipes200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple recipes.
     */
    async storeMultipleRecipes(requestParameters: StoreMultipleRecipesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleRecipes200Response> {
        const response = await this.storeMultipleRecipesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store recipe.
     */
    async storeRecipeRaw(requestParameters: StoreRecipeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreRecipeResponse>> {
        if (requestParameters.storeRecipeRequest === null || requestParameters.storeRecipeRequest === undefined) {
            throw new runtime.RequiredError('storeRecipeRequest','Required parameter requestParameters.storeRecipeRequest was null or undefined when calling storeRecipe.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/recipes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreRecipeRequestToJSON(requestParameters.storeRecipeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreRecipeResponseFromJSON(jsonValue));
    }

    /**
     * Store recipe.
     */
    async storeRecipe(requestParameters: StoreRecipeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreRecipeResponse> {
        const response = await this.storeRecipeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple recipes.
     */
    async updateMultipleRecipesRaw(requestParameters: UpdateMultipleRecipesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleRecipes200Response>> {
        if (requestParameters.updateMultipleRecipesRequest === null || requestParameters.updateMultipleRecipesRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleRecipesRequest','Required parameter requestParameters.updateMultipleRecipesRequest was null or undefined when calling updateMultipleRecipes.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/recipes/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleRecipesRequestToJSON(requestParameters.updateMultipleRecipesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleRecipes200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple recipes.
     */
    async updateMultipleRecipes(requestParameters: UpdateMultipleRecipesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleRecipes200Response> {
        const response = await this.updateMultipleRecipesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update recipe.
     */
    async updateRecipeRaw(requestParameters: UpdateRecipeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateRecipeResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateRecipe.');
        }

        if (requestParameters.updateRecipeRequest === null || requestParameters.updateRecipeRequest === undefined) {
            throw new runtime.RequiredError('updateRecipeRequest','Required parameter requestParameters.updateRecipeRequest was null or undefined when calling updateRecipe.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/recipes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateRecipeRequestToJSON(requestParameters.updateRecipeRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateRecipeResponseFromJSON(jsonValue));
    }

    /**
     * Update recipe.
     */
    async updateRecipe(requestParameters: UpdateRecipeOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateRecipeResponse> {
        const response = await this.updateRecipeRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportRecipesFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportRecipesFormatEnum = typeof ExportRecipesFormatEnum[keyof typeof ExportRecipesFormatEnum];
