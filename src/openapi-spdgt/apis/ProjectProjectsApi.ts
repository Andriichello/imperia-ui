/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CheckProjectAbbreviationResponse,
  DestroyResponse,
  ExportIndexResponse,
  IndexProjectsResponse,
  ShowProjectResponse,
  StoreMultipleProjects200Response,
  StoreMultipleProjectsRequest,
  StoreProjectRequest,
  StoreProjectResponse,
  UpdateMultipleProjects200Response,
  UpdateMultipleProjectsRequest,
  UpdateProjectRequest,
  UpdateProjectResponse,
} from '../models';
import {
    CheckProjectAbbreviationResponseFromJSON,
    CheckProjectAbbreviationResponseToJSON,
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexProjectsResponseFromJSON,
    IndexProjectsResponseToJSON,
    ShowProjectResponseFromJSON,
    ShowProjectResponseToJSON,
    StoreMultipleProjects200ResponseFromJSON,
    StoreMultipleProjects200ResponseToJSON,
    StoreMultipleProjectsRequestFromJSON,
    StoreMultipleProjectsRequestToJSON,
    StoreProjectRequestFromJSON,
    StoreProjectRequestToJSON,
    StoreProjectResponseFromJSON,
    StoreProjectResponseToJSON,
    UpdateMultipleProjects200ResponseFromJSON,
    UpdateMultipleProjects200ResponseToJSON,
    UpdateMultipleProjectsRequestFromJSON,
    UpdateMultipleProjectsRequestToJSON,
    UpdateProjectRequestFromJSON,
    UpdateProjectRequestToJSON,
    UpdateProjectResponseFromJSON,
    UpdateProjectResponseToJSON,
} from '../models';

export interface CheckProjectAbbreviationRequest {
    abbreviation: string;
}

export interface DestroyProjectRequest {
    id: number;
}

export interface ExportProjectsRequest {
    format: ExportProjectsFormatEnum;
    appends?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    srid?: number;
    filterId?: string;
    filterParentProjectId?: string;
    filterSrid?: string;
    filterName?: string;
    filterAbbreviation?: string;
    filterDescription?: string;
    filterUrl?: string;
    filterLogo?: string;
    filterAnalysisUnit?: string;
    filterManagementUnit?: string;
    filterMetadata?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface IndexProjectsRequest {
    appends?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    srid?: number;
    filterId?: string;
    filterParentProjectId?: string;
    filterSrid?: string;
    filterName?: string;
    filterAbbreviation?: string;
    filterDescription?: string;
    filterUrl?: string;
    filterLogo?: string;
    filterAnalysisUnit?: string;
    filterManagementUnit?: string;
    filterMetadata?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface ShowProjectRequest {
    id: number;
    appends?: string;
    srid?: number;
}

export interface StoreMultipleProjectsOperationRequest {
    storeMultipleProjectsRequest: StoreMultipleProjectsRequest;
}

export interface StoreProjectOperationRequest {
    storeProjectRequest: StoreProjectRequest;
}

export interface UpdateMultipleProjectsOperationRequest {
    updateMultipleProjectsRequest: UpdateMultipleProjectsRequest;
}

export interface UpdateProjectOperationRequest {
    id: number;
    updateProjectRequest: UpdateProjectRequest;
}

/**
 * 
 */
export class ProjectProjectsApi extends runtime.BaseAPI {

    /**
     * Check if project abbreviation exists.
     */
    async checkProjectAbbreviationRaw(requestParameters: CheckProjectAbbreviationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckProjectAbbreviationResponse>> {
        if (requestParameters.abbreviation === null || requestParameters.abbreviation === undefined) {
            throw new runtime.RequiredError('abbreviation','Required parameter requestParameters.abbreviation was null or undefined when calling checkProjectAbbreviation.');
        }

        const queryParameters: any = {};

        if (requestParameters.abbreviation !== undefined) {
            queryParameters['abbreviation'] = requestParameters.abbreviation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects/check`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckProjectAbbreviationResponseFromJSON(jsonValue));
    }

    /**
     * Check if project abbreviation exists.
     */
    async checkProjectAbbreviation(requestParameters: CheckProjectAbbreviationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckProjectAbbreviationResponse> {
        const response = await this.checkProjectAbbreviationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete project.
     */
    async destroyProjectRaw(requestParameters: DestroyProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete project.
     */
    async destroyProject(requestParameters: DestroyProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export projects in a selected format (csv, json, parquet).
     */
    async exportProjectsRaw(requestParameters: ExportProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportProjects.');
        }

        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.srid !== undefined) {
            queryParameters['srid'] = requestParameters.srid;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterParentProjectId !== undefined) {
            queryParameters['filter[parent_project_id]'] = requestParameters.filterParentProjectId;
        }

        if (requestParameters.filterSrid !== undefined) {
            queryParameters['filter[srid]'] = requestParameters.filterSrid;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterAbbreviation !== undefined) {
            queryParameters['filter[abbreviation]'] = requestParameters.filterAbbreviation;
        }

        if (requestParameters.filterDescription !== undefined) {
            queryParameters['filter[description]'] = requestParameters.filterDescription;
        }

        if (requestParameters.filterUrl !== undefined) {
            queryParameters['filter[url]'] = requestParameters.filterUrl;
        }

        if (requestParameters.filterLogo !== undefined) {
            queryParameters['filter[logo]'] = requestParameters.filterLogo;
        }

        if (requestParameters.filterAnalysisUnit !== undefined) {
            queryParameters['filter[analysis_unit]'] = requestParameters.filterAnalysisUnit;
        }

        if (requestParameters.filterManagementUnit !== undefined) {
            queryParameters['filter[management_unit]'] = requestParameters.filterManagementUnit;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export projects in a selected format (csv, json, parquet).
     */
    async exportProjects(requestParameters: ExportProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index projects.
     */
    async indexProjectsRaw(requestParameters: IndexProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexProjectsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.srid !== undefined) {
            queryParameters['srid'] = requestParameters.srid;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterParentProjectId !== undefined) {
            queryParameters['filter[parent_project_id]'] = requestParameters.filterParentProjectId;
        }

        if (requestParameters.filterSrid !== undefined) {
            queryParameters['filter[srid]'] = requestParameters.filterSrid;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterAbbreviation !== undefined) {
            queryParameters['filter[abbreviation]'] = requestParameters.filterAbbreviation;
        }

        if (requestParameters.filterDescription !== undefined) {
            queryParameters['filter[description]'] = requestParameters.filterDescription;
        }

        if (requestParameters.filterUrl !== undefined) {
            queryParameters['filter[url]'] = requestParameters.filterUrl;
        }

        if (requestParameters.filterLogo !== undefined) {
            queryParameters['filter[logo]'] = requestParameters.filterLogo;
        }

        if (requestParameters.filterAnalysisUnit !== undefined) {
            queryParameters['filter[analysis_unit]'] = requestParameters.filterAnalysisUnit;
        }

        if (requestParameters.filterManagementUnit !== undefined) {
            queryParameters['filter[management_unit]'] = requestParameters.filterManagementUnit;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexProjectsResponseFromJSON(jsonValue));
    }

    /**
     * Index projects.
     */
    async indexProjects(requestParameters: IndexProjectsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexProjectsResponse> {
        const response = await this.indexProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show project by id.
     */
    async showProjectRaw(requestParameters: ShowProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowProjectResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showProject.');
        }

        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.srid !== undefined) {
            queryParameters['srid'] = requestParameters.srid;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowProjectResponseFromJSON(jsonValue));
    }

    /**
     * Show project by id.
     */
    async showProject(requestParameters: ShowProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowProjectResponse> {
        const response = await this.showProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple projects.
     */
    async storeMultipleProjectsRaw(requestParameters: StoreMultipleProjectsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleProjects200Response>> {
        if (requestParameters.storeMultipleProjectsRequest === null || requestParameters.storeMultipleProjectsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleProjectsRequest','Required parameter requestParameters.storeMultipleProjectsRequest was null or undefined when calling storeMultipleProjects.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleProjectsRequestToJSON(requestParameters.storeMultipleProjectsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleProjects200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple projects.
     */
    async storeMultipleProjects(requestParameters: StoreMultipleProjectsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleProjects200Response> {
        const response = await this.storeMultipleProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store project.
     */
    async storeProjectRaw(requestParameters: StoreProjectOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreProjectResponse>> {
        if (requestParameters.storeProjectRequest === null || requestParameters.storeProjectRequest === undefined) {
            throw new runtime.RequiredError('storeProjectRequest','Required parameter requestParameters.storeProjectRequest was null or undefined when calling storeProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreProjectRequestToJSON(requestParameters.storeProjectRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreProjectResponseFromJSON(jsonValue));
    }

    /**
     * Store project.
     */
    async storeProject(requestParameters: StoreProjectOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreProjectResponse> {
        const response = await this.storeProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple projects.
     */
    async updateMultipleProjectsRaw(requestParameters: UpdateMultipleProjectsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleProjects200Response>> {
        if (requestParameters.updateMultipleProjectsRequest === null || requestParameters.updateMultipleProjectsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleProjectsRequest','Required parameter requestParameters.updateMultipleProjectsRequest was null or undefined when calling updateMultipleProjects.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleProjectsRequestToJSON(requestParameters.updateMultipleProjectsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleProjects200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple projects.
     */
    async updateMultipleProjects(requestParameters: UpdateMultipleProjectsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleProjects200Response> {
        const response = await this.updateMultipleProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update project.
     */
    async updateProjectRaw(requestParameters: UpdateProjectOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateProjectResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateProject.');
        }

        if (requestParameters.updateProjectRequest === null || requestParameters.updateProjectRequest === undefined) {
            throw new runtime.RequiredError('updateProjectRequest','Required parameter requestParameters.updateProjectRequest was null or undefined when calling updateProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/projects/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateProjectRequestToJSON(requestParameters.updateProjectRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateProjectResponseFromJSON(jsonValue));
    }

    /**
     * Update project.
     */
    async updateProject(requestParameters: UpdateProjectOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateProjectResponse> {
        const response = await this.updateProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportProjectsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportProjectsFormatEnum = typeof ExportProjectsFormatEnum[keyof typeof ExportProjectsFormatEnum];
