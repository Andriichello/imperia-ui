/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AttachSurveyTypeToModelRequest,
  AttachSurveyTypeToModelResponse,
  DestroyResponse,
  DetachSurveyTypeFromModelRequest,
  DetachSurveyTypeFromModelResponse,
  ExportIndexResponse,
  IndexModelsResponse,
  ShowModelResponse,
  StoreModelRequest,
  StoreModelResponse,
  StoreMultipleModels200Response,
  StoreMultipleModelsRequest,
  UpdateModelRequest,
  UpdateModelResponse,
  UpdateMultipleModels200Response,
  UpdateMultipleModelsRequest,
} from '../models';
import {
    AttachSurveyTypeToModelRequestFromJSON,
    AttachSurveyTypeToModelRequestToJSON,
    AttachSurveyTypeToModelResponseFromJSON,
    AttachSurveyTypeToModelResponseToJSON,
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    DetachSurveyTypeFromModelRequestFromJSON,
    DetachSurveyTypeFromModelRequestToJSON,
    DetachSurveyTypeFromModelResponseFromJSON,
    DetachSurveyTypeFromModelResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexModelsResponseFromJSON,
    IndexModelsResponseToJSON,
    ShowModelResponseFromJSON,
    ShowModelResponseToJSON,
    StoreModelRequestFromJSON,
    StoreModelRequestToJSON,
    StoreModelResponseFromJSON,
    StoreModelResponseToJSON,
    StoreMultipleModels200ResponseFromJSON,
    StoreMultipleModels200ResponseToJSON,
    StoreMultipleModelsRequestFromJSON,
    StoreMultipleModelsRequestToJSON,
    UpdateModelRequestFromJSON,
    UpdateModelRequestToJSON,
    UpdateModelResponseFromJSON,
    UpdateModelResponseToJSON,
    UpdateMultipleModels200ResponseFromJSON,
    UpdateMultipleModels200ResponseToJSON,
    UpdateMultipleModelsRequestFromJSON,
    UpdateMultipleModelsRequestToJSON,
} from '../models';

export interface AttachSurveyTypeToModelOperationRequest {
    attachSurveyTypeToModelRequest: AttachSurveyTypeToModelRequest;
}

export interface DestroyModelRequest {
    id: number;
}

export interface DetachSurveyTypeFromModelOperationRequest {
    detachSurveyTypeFromModelRequest: DetachSurveyTypeFromModelRequest;
}

export interface ExportModelsRequest {
    format: ExportModelsFormatEnum;
    appends?: string;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterSurveyTypeId?: string;
    filterType?: string;
    filterName?: string;
    filterApproach?: string;
    filterProcSuffix?: string;
    filterDefinition?: string;
    filterMetadata?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface IndexModelsRequest {
    appends?: string;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterSurveyTypeId?: string;
    filterType?: string;
    filterName?: string;
    filterApproach?: string;
    filterProcSuffix?: string;
    filterDefinition?: string;
    filterMetadata?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface ShowModelRequest {
    id: number;
    appends?: string;
    includes?: string;
}

export interface StoreModelOperationRequest {
    storeModelRequest: StoreModelRequest;
}

export interface StoreMultipleModelsOperationRequest {
    storeMultipleModelsRequest: StoreMultipleModelsRequest;
}

export interface UpdateModelOperationRequest {
    id: number;
    updateModelRequest: UpdateModelRequest;
}

export interface UpdateMultipleModelsOperationRequest {
    updateMultipleModelsRequest: UpdateMultipleModelsRequest;
}

/**
 * 
 */
export class ModelModelsApi extends runtime.BaseAPI {

    /**
     * Attach survey type to model.
     */
    async attachSurveyTypeToModelRaw(requestParameters: AttachSurveyTypeToModelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AttachSurveyTypeToModelResponse>> {
        if (requestParameters.attachSurveyTypeToModelRequest === null || requestParameters.attachSurveyTypeToModelRequest === undefined) {
            throw new runtime.RequiredError('attachSurveyTypeToModelRequest','Required parameter requestParameters.attachSurveyTypeToModelRequest was null or undefined when calling attachSurveyTypeToModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/survey-types/attach`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AttachSurveyTypeToModelRequestToJSON(requestParameters.attachSurveyTypeToModelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AttachSurveyTypeToModelResponseFromJSON(jsonValue));
    }

    /**
     * Attach survey type to model.
     */
    async attachSurveyTypeToModel(requestParameters: AttachSurveyTypeToModelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AttachSurveyTypeToModelResponse> {
        const response = await this.attachSurveyTypeToModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete model.
     */
    async destroyModelRaw(requestParameters: DestroyModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete model.
     */
    async destroyModel(requestParameters: DestroyModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Detach survey type from model.
     */
    async detachSurveyTypeFromModelRaw(requestParameters: DetachSurveyTypeFromModelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DetachSurveyTypeFromModelResponse>> {
        if (requestParameters.detachSurveyTypeFromModelRequest === null || requestParameters.detachSurveyTypeFromModelRequest === undefined) {
            throw new runtime.RequiredError('detachSurveyTypeFromModelRequest','Required parameter requestParameters.detachSurveyTypeFromModelRequest was null or undefined when calling detachSurveyTypeFromModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/survey-types/detach`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DetachSurveyTypeFromModelRequestToJSON(requestParameters.detachSurveyTypeFromModelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DetachSurveyTypeFromModelResponseFromJSON(jsonValue));
    }

    /**
     * Detach survey type from model.
     */
    async detachSurveyTypeFromModel(requestParameters: DetachSurveyTypeFromModelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DetachSurveyTypeFromModelResponse> {
        const response = await this.detachSurveyTypeFromModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export models in a selected format (csv, json, parquet).
     */
    async exportModelsRaw(requestParameters: ExportModelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportModels.');
        }

        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterType !== undefined) {
            queryParameters['filter[type]'] = requestParameters.filterType;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterApproach !== undefined) {
            queryParameters['filter[approach]'] = requestParameters.filterApproach;
        }

        if (requestParameters.filterProcSuffix !== undefined) {
            queryParameters['filter[proc_suffix]'] = requestParameters.filterProcSuffix;
        }

        if (requestParameters.filterDefinition !== undefined) {
            queryParameters['filter[definition]'] = requestParameters.filterDefinition;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export models in a selected format (csv, json, parquet).
     */
    async exportModels(requestParameters: ExportModelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportModelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index models.
     */
    async indexModelsRaw(requestParameters: IndexModelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexModelsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterType !== undefined) {
            queryParameters['filter[type]'] = requestParameters.filterType;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterApproach !== undefined) {
            queryParameters['filter[approach]'] = requestParameters.filterApproach;
        }

        if (requestParameters.filterProcSuffix !== undefined) {
            queryParameters['filter[proc_suffix]'] = requestParameters.filterProcSuffix;
        }

        if (requestParameters.filterDefinition !== undefined) {
            queryParameters['filter[definition]'] = requestParameters.filterDefinition;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexModelsResponseFromJSON(jsonValue));
    }

    /**
     * Index models.
     */
    async indexModels(requestParameters: IndexModelsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexModelsResponse> {
        const response = await this.indexModelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show model by id.
     */
    async showModelRaw(requestParameters: ShowModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowModelResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showModel.');
        }

        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowModelResponseFromJSON(jsonValue));
    }

    /**
     * Show model by id.
     */
    async showModel(requestParameters: ShowModelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowModelResponse> {
        const response = await this.showModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store model.
     */
    async storeModelRaw(requestParameters: StoreModelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreModelResponse>> {
        if (requestParameters.storeModelRequest === null || requestParameters.storeModelRequest === undefined) {
            throw new runtime.RequiredError('storeModelRequest','Required parameter requestParameters.storeModelRequest was null or undefined when calling storeModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreModelRequestToJSON(requestParameters.storeModelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreModelResponseFromJSON(jsonValue));
    }

    /**
     * Store model.
     */
    async storeModel(requestParameters: StoreModelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreModelResponse> {
        const response = await this.storeModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple models.
     */
    async storeMultipleModelsRaw(requestParameters: StoreMultipleModelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleModels200Response>> {
        if (requestParameters.storeMultipleModelsRequest === null || requestParameters.storeMultipleModelsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleModelsRequest','Required parameter requestParameters.storeMultipleModelsRequest was null or undefined when calling storeMultipleModels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleModelsRequestToJSON(requestParameters.storeMultipleModelsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleModels200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple models.
     */
    async storeMultipleModels(requestParameters: StoreMultipleModelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleModels200Response> {
        const response = await this.storeMultipleModelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update model.
     */
    async updateModelRaw(requestParameters: UpdateModelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateModelResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateModel.');
        }

        if (requestParameters.updateModelRequest === null || requestParameters.updateModelRequest === undefined) {
            throw new runtime.RequiredError('updateModelRequest','Required parameter requestParameters.updateModelRequest was null or undefined when calling updateModel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateModelRequestToJSON(requestParameters.updateModelRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateModelResponseFromJSON(jsonValue));
    }

    /**
     * Update model.
     */
    async updateModel(requestParameters: UpdateModelOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateModelResponse> {
        const response = await this.updateModelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple models.
     */
    async updateMultipleModelsRaw(requestParameters: UpdateMultipleModelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleModels200Response>> {
        if (requestParameters.updateMultipleModelsRequest === null || requestParameters.updateMultipleModelsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleModelsRequest','Required parameter requestParameters.updateMultipleModelsRequest was null or undefined when calling updateMultipleModels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleModelsRequestToJSON(requestParameters.updateMultipleModelsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleModels200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple models.
     */
    async updateMultipleModels(requestParameters: UpdateMultipleModelsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleModels200Response> {
        const response = await this.updateMultipleModelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportModelsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportModelsFormatEnum = typeof ExportModelsFormatEnum[keyof typeof ExportModelsFormatEnum];
