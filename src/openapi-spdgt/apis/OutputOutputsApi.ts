/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexOutputsResponse,
  ShowOutputResponse,
  StoreMultipleOutputs200Response,
  StoreMultipleOutputsRequest,
  StoreOutputRequest,
  StoreOutputResponse,
  UpdateMultipleOutputs200Response,
  UpdateMultipleOutputsRequest,
  UpdateOutputRequest,
  UpdateOutputResponse,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexOutputsResponseFromJSON,
    IndexOutputsResponseToJSON,
    ShowOutputResponseFromJSON,
    ShowOutputResponseToJSON,
    StoreMultipleOutputs200ResponseFromJSON,
    StoreMultipleOutputs200ResponseToJSON,
    StoreMultipleOutputsRequestFromJSON,
    StoreMultipleOutputsRequestToJSON,
    StoreOutputRequestFromJSON,
    StoreOutputRequestToJSON,
    StoreOutputResponseFromJSON,
    StoreOutputResponseToJSON,
    UpdateMultipleOutputs200ResponseFromJSON,
    UpdateMultipleOutputs200ResponseToJSON,
    UpdateMultipleOutputsRequestFromJSON,
    UpdateMultipleOutputsRequestToJSON,
    UpdateOutputRequestFromJSON,
    UpdateOutputRequestToJSON,
    UpdateOutputResponseFromJSON,
    UpdateOutputResponseToJSON,
} from '../models';

export interface DestroyOutputRequest {
    id: number;
}

export interface ExportOutputsRequest {
    format: ExportOutputsFormatEnum;
    appends?: string;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterProjectId?: string;
    filterModelId?: string;
    filterRecipeId?: string;
    filterContextId?: string;
    filterContextType?: string;
    filterMetadata?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface IndexOutputsRequest {
    appends?: string;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterProjectId?: string;
    filterModelId?: string;
    filterRecipeId?: string;
    filterMetadata?: string;
    filterContextId?: string;
    filterContextType?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface ShowOutputRequest {
    id: number;
    appends?: string;
    includes?: string;
}

export interface StoreMultipleOutputsOperationRequest {
    storeMultipleOutputsRequest: StoreMultipleOutputsRequest;
}

export interface StoreOutputOperationRequest {
    storeOutputRequest: StoreOutputRequest;
}

export interface UpdateMultipleOutputsOperationRequest {
    updateMultipleOutputsRequest: UpdateMultipleOutputsRequest;
}

export interface UpdateOutputOperationRequest {
    id: number;
    updateOutputRequest: UpdateOutputRequest;
}

/**
 * 
 */
export class OutputOutputsApi extends runtime.BaseAPI {

    /**
     * Delete model output.
     */
    async destroyOutputRaw(requestParameters: DestroyOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyOutput.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/outputs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete model output.
     */
    async destroyOutput(requestParameters: DestroyOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export model outputs in a selected format (csv, json, parquet).
     */
    async exportOutputsRaw(requestParameters: ExportOutputsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportOutputs.');
        }

        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterProjectId !== undefined) {
            queryParameters['filter[project_id]'] = requestParameters.filterProjectId;
        }

        if (requestParameters.filterModelId !== undefined) {
            queryParameters['filter[model_id]'] = requestParameters.filterModelId;
        }

        if (requestParameters.filterRecipeId !== undefined) {
            queryParameters['filter[recipe_id]'] = requestParameters.filterRecipeId;
        }

        if (requestParameters.filterContextId !== undefined) {
            queryParameters['filter[context_id]'] = requestParameters.filterContextId;
        }

        if (requestParameters.filterContextType !== undefined) {
            queryParameters['filter[context_type]'] = requestParameters.filterContextType;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/outputs/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export model outputs in a selected format (csv, json, parquet).
     */
    async exportOutputs(requestParameters: ExportOutputsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportOutputsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index model outputs.
     */
    async indexOutputsRaw(requestParameters: IndexOutputsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexOutputsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterProjectId !== undefined) {
            queryParameters['filter[project_id]'] = requestParameters.filterProjectId;
        }

        if (requestParameters.filterModelId !== undefined) {
            queryParameters['filter[model_id]'] = requestParameters.filterModelId;
        }

        if (requestParameters.filterRecipeId !== undefined) {
            queryParameters['filter[recipe_id]'] = requestParameters.filterRecipeId;
        }

        if (requestParameters.filterMetadata !== undefined) {
            queryParameters['filter[metadata]'] = requestParameters.filterMetadata;
        }

        if (requestParameters.filterContextId !== undefined) {
            queryParameters['filter[context_id]'] = requestParameters.filterContextId;
        }

        if (requestParameters.filterContextType !== undefined) {
            queryParameters['filter[context_type]'] = requestParameters.filterContextType;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/outputs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexOutputsResponseFromJSON(jsonValue));
    }

    /**
     * Index model outputs.
     */
    async indexOutputs(requestParameters: IndexOutputsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexOutputsResponse> {
        const response = await this.indexOutputsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show model output by id.
     */
    async showOutputRaw(requestParameters: ShowOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowOutputResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showOutput.');
        }

        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/outputs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowOutputResponseFromJSON(jsonValue));
    }

    /**
     * Show model output by id.
     */
    async showOutput(requestParameters: ShowOutputRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowOutputResponse> {
        const response = await this.showOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple outputs.
     */
    async storeMultipleOutputsRaw(requestParameters: StoreMultipleOutputsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleOutputs200Response>> {
        if (requestParameters.storeMultipleOutputsRequest === null || requestParameters.storeMultipleOutputsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleOutputsRequest','Required parameter requestParameters.storeMultipleOutputsRequest was null or undefined when calling storeMultipleOutputs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/outputs/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleOutputsRequestToJSON(requestParameters.storeMultipleOutputsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleOutputs200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple outputs.
     */
    async storeMultipleOutputs(requestParameters: StoreMultipleOutputsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleOutputs200Response> {
        const response = await this.storeMultipleOutputsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store model output.
     */
    async storeOutputRaw(requestParameters: StoreOutputOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreOutputResponse>> {
        if (requestParameters.storeOutputRequest === null || requestParameters.storeOutputRequest === undefined) {
            throw new runtime.RequiredError('storeOutputRequest','Required parameter requestParameters.storeOutputRequest was null or undefined when calling storeOutput.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/outputs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreOutputRequestToJSON(requestParameters.storeOutputRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreOutputResponseFromJSON(jsonValue));
    }

    /**
     * Store model output.
     */
    async storeOutput(requestParameters: StoreOutputOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreOutputResponse> {
        const response = await this.storeOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple outputs.
     */
    async updateMultipleOutputsRaw(requestParameters: UpdateMultipleOutputsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleOutputs200Response>> {
        if (requestParameters.updateMultipleOutputsRequest === null || requestParameters.updateMultipleOutputsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleOutputsRequest','Required parameter requestParameters.updateMultipleOutputsRequest was null or undefined when calling updateMultipleOutputs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/outputs/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleOutputsRequestToJSON(requestParameters.updateMultipleOutputsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleOutputs200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple outputs.
     */
    async updateMultipleOutputs(requestParameters: UpdateMultipleOutputsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleOutputs200Response> {
        const response = await this.updateMultipleOutputsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update model output.
     */
    async updateOutputRaw(requestParameters: UpdateOutputOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateOutputResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateOutput.');
        }

        if (requestParameters.updateOutputRequest === null || requestParameters.updateOutputRequest === undefined) {
            throw new runtime.RequiredError('updateOutputRequest','Required parameter requestParameters.updateOutputRequest was null or undefined when calling updateOutput.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/models/outputs/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateOutputRequestToJSON(requestParameters.updateOutputRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateOutputResponseFromJSON(jsonValue));
    }

    /**
     * Update model output.
     */
    async updateOutput(requestParameters: UpdateOutputOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateOutputResponse> {
        const response = await this.updateOutputRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportOutputsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportOutputsFormatEnum = typeof ExportOutputsFormatEnum[keyof typeof ExportOutputsFormatEnum];
