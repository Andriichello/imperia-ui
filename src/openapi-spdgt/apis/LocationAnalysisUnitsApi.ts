/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexAnalysisUnitsResponse,
  ShowAnalysisUnitResponse,
  StoreAnalysisUnitRequest,
  StoreAnalysisUnitResponse,
  StoreMultipleAnalysisUnits200Response,
  StoreMultipleAnalysisUnitsRequest,
  UpdateAnalysisUnitRequest,
  UpdateAnalysisUnitResponse,
  UpdateMultipleAnalysisUnits200Response,
  UpdateMultipleAnalysisUnitsRequest,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexAnalysisUnitsResponseFromJSON,
    IndexAnalysisUnitsResponseToJSON,
    ShowAnalysisUnitResponseFromJSON,
    ShowAnalysisUnitResponseToJSON,
    StoreAnalysisUnitRequestFromJSON,
    StoreAnalysisUnitRequestToJSON,
    StoreAnalysisUnitResponseFromJSON,
    StoreAnalysisUnitResponseToJSON,
    StoreMultipleAnalysisUnits200ResponseFromJSON,
    StoreMultipleAnalysisUnits200ResponseToJSON,
    StoreMultipleAnalysisUnitsRequestFromJSON,
    StoreMultipleAnalysisUnitsRequestToJSON,
    UpdateAnalysisUnitRequestFromJSON,
    UpdateAnalysisUnitRequestToJSON,
    UpdateAnalysisUnitResponseFromJSON,
    UpdateAnalysisUnitResponseToJSON,
    UpdateMultipleAnalysisUnits200ResponseFromJSON,
    UpdateMultipleAnalysisUnits200ResponseToJSON,
    UpdateMultipleAnalysisUnitsRequestFromJSON,
    UpdateMultipleAnalysisUnitsRequestToJSON,
} from '../models';

export interface DestroyAnalysisUnitRequest {
    id: number;
}

export interface ExportAnalysisUnitsRequest {
    format: ExportAnalysisUnitsFormatEnum;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterVersionId?: string;
    filterProjectId?: string;
    filterSpeciesId?: string;
    filterNumber?: string;
    filterName?: string;
    filterAbbreviation?: string;
    filterSortOrder?: string;
}

export interface IndexAnalysisUnitsRequest {
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterVersionId?: string;
    filterProjectId?: string;
    filterSpeciesId?: string;
    filterNumber?: string;
    filterName?: string;
    filterAbbreviation?: string;
    filterSortOrder?: string;
}

export interface ShowAnalysisUnitRequest {
    id: number;
    includes?: string;
}

export interface StoreAnalysisUnitOperationRequest {
    storeAnalysisUnitRequest: StoreAnalysisUnitRequest;
}

export interface StoreMultipleAnalysisUnitsOperationRequest {
    storeMultipleAnalysisUnitsRequest: StoreMultipleAnalysisUnitsRequest;
}

export interface UpdateAnalysisUnitOperationRequest {
    id: number;
    updateAnalysisUnitRequest: UpdateAnalysisUnitRequest;
}

export interface UpdateMultipleAnalysisUnitsOperationRequest {
    updateMultipleAnalysisUnitsRequest: UpdateMultipleAnalysisUnitsRequest;
}

/**
 * 
 */
export class LocationAnalysisUnitsApi extends runtime.BaseAPI {

    /**
     * Delete analysis unit.
     */
    async destroyAnalysisUnitRaw(requestParameters: DestroyAnalysisUnitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyAnalysisUnit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/analysis-units/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete analysis unit.
     */
    async destroyAnalysisUnit(requestParameters: DestroyAnalysisUnitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyAnalysisUnitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export analysis units in a selected format (csv, json, parquet).
     */
    async exportAnalysisUnitsRaw(requestParameters: ExportAnalysisUnitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportAnalysisUnits.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterVersionId !== undefined) {
            queryParameters['filter[version_id]'] = requestParameters.filterVersionId;
        }

        if (requestParameters.filterProjectId !== undefined) {
            queryParameters['filter[project_id]'] = requestParameters.filterProjectId;
        }

        if (requestParameters.filterSpeciesId !== undefined) {
            queryParameters['filter[species_id]'] = requestParameters.filterSpeciesId;
        }

        if (requestParameters.filterNumber !== undefined) {
            queryParameters['filter[number]'] = requestParameters.filterNumber;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterAbbreviation !== undefined) {
            queryParameters['filter[abbreviation]'] = requestParameters.filterAbbreviation;
        }

        if (requestParameters.filterSortOrder !== undefined) {
            queryParameters['filter[sort_order]'] = requestParameters.filterSortOrder;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/analysis-units/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export analysis units in a selected format (csv, json, parquet).
     */
    async exportAnalysisUnits(requestParameters: ExportAnalysisUnitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportAnalysisUnitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index analysis units.
     */
    async indexAnalysisUnitsRaw(requestParameters: IndexAnalysisUnitsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexAnalysisUnitsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterVersionId !== undefined) {
            queryParameters['filter[version_id]'] = requestParameters.filterVersionId;
        }

        if (requestParameters.filterProjectId !== undefined) {
            queryParameters['filter[project_id]'] = requestParameters.filterProjectId;
        }

        if (requestParameters.filterSpeciesId !== undefined) {
            queryParameters['filter[species_id]'] = requestParameters.filterSpeciesId;
        }

        if (requestParameters.filterNumber !== undefined) {
            queryParameters['filter[number]'] = requestParameters.filterNumber;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterAbbreviation !== undefined) {
            queryParameters['filter[abbreviation]'] = requestParameters.filterAbbreviation;
        }

        if (requestParameters.filterSortOrder !== undefined) {
            queryParameters['filter[sort_order]'] = requestParameters.filterSortOrder;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/analysis-units`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexAnalysisUnitsResponseFromJSON(jsonValue));
    }

    /**
     * Index analysis units.
     */
    async indexAnalysisUnits(requestParameters: IndexAnalysisUnitsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexAnalysisUnitsResponse> {
        const response = await this.indexAnalysisUnitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show analysis unit by id.
     */
    async showAnalysisUnitRaw(requestParameters: ShowAnalysisUnitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowAnalysisUnitResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showAnalysisUnit.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/analysis-units/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowAnalysisUnitResponseFromJSON(jsonValue));
    }

    /**
     * Show analysis unit by id.
     */
    async showAnalysisUnit(requestParameters: ShowAnalysisUnitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowAnalysisUnitResponse> {
        const response = await this.showAnalysisUnitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store analysis unit.
     */
    async storeAnalysisUnitRaw(requestParameters: StoreAnalysisUnitOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreAnalysisUnitResponse>> {
        if (requestParameters.storeAnalysisUnitRequest === null || requestParameters.storeAnalysisUnitRequest === undefined) {
            throw new runtime.RequiredError('storeAnalysisUnitRequest','Required parameter requestParameters.storeAnalysisUnitRequest was null or undefined when calling storeAnalysisUnit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/analysis-units`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreAnalysisUnitRequestToJSON(requestParameters.storeAnalysisUnitRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreAnalysisUnitResponseFromJSON(jsonValue));
    }

    /**
     * Store analysis unit.
     */
    async storeAnalysisUnit(requestParameters: StoreAnalysisUnitOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreAnalysisUnitResponse> {
        const response = await this.storeAnalysisUnitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple analysis units.
     */
    async storeMultipleAnalysisUnitsRaw(requestParameters: StoreMultipleAnalysisUnitsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleAnalysisUnits200Response>> {
        if (requestParameters.storeMultipleAnalysisUnitsRequest === null || requestParameters.storeMultipleAnalysisUnitsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleAnalysisUnitsRequest','Required parameter requestParameters.storeMultipleAnalysisUnitsRequest was null or undefined when calling storeMultipleAnalysisUnits.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/analysis-units/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleAnalysisUnitsRequestToJSON(requestParameters.storeMultipleAnalysisUnitsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleAnalysisUnits200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple analysis units.
     */
    async storeMultipleAnalysisUnits(requestParameters: StoreMultipleAnalysisUnitsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleAnalysisUnits200Response> {
        const response = await this.storeMultipleAnalysisUnitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update analysis unit.
     */
    async updateAnalysisUnitRaw(requestParameters: UpdateAnalysisUnitOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateAnalysisUnitResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateAnalysisUnit.');
        }

        if (requestParameters.updateAnalysisUnitRequest === null || requestParameters.updateAnalysisUnitRequest === undefined) {
            throw new runtime.RequiredError('updateAnalysisUnitRequest','Required parameter requestParameters.updateAnalysisUnitRequest was null or undefined when calling updateAnalysisUnit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/analysis-units/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAnalysisUnitRequestToJSON(requestParameters.updateAnalysisUnitRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateAnalysisUnitResponseFromJSON(jsonValue));
    }

    /**
     * Update analysis unit.
     */
    async updateAnalysisUnit(requestParameters: UpdateAnalysisUnitOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateAnalysisUnitResponse> {
        const response = await this.updateAnalysisUnitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple analysis units.
     */
    async updateMultipleAnalysisUnitsRaw(requestParameters: UpdateMultipleAnalysisUnitsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleAnalysisUnits200Response>> {
        if (requestParameters.updateMultipleAnalysisUnitsRequest === null || requestParameters.updateMultipleAnalysisUnitsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleAnalysisUnitsRequest','Required parameter requestParameters.updateMultipleAnalysisUnitsRequest was null or undefined when calling updateMultipleAnalysisUnits.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/analysis-units/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleAnalysisUnitsRequestToJSON(requestParameters.updateMultipleAnalysisUnitsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleAnalysisUnits200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple analysis units.
     */
    async updateMultipleAnalysisUnits(requestParameters: UpdateMultipleAnalysisUnitsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleAnalysisUnits200Response> {
        const response = await this.updateMultipleAnalysisUnitsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportAnalysisUnitsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportAnalysisUnitsFormatEnum = typeof ExportAnalysisUnitsFormatEnum[keyof typeof ExportAnalysisUnitsFormatEnum];
