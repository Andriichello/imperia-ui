/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexEntryColumnMappingsResponse,
  ShowEntryColumnMappingResponse,
  StoreEntryColumnMappingRequest,
  StoreEntryColumnMappingResponse,
  StoreMultipleEntryColumnMappings200Response,
  StoreMultipleEntryColumnMappingsRequest,
  UpdateEntryColumnMappingRequest,
  UpdateEntryColumnMappingResponse,
  UpdateMultipleEntryColumnMappings200Response,
  UpdateMultipleEntryColumnMappingsRequest,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexEntryColumnMappingsResponseFromJSON,
    IndexEntryColumnMappingsResponseToJSON,
    ShowEntryColumnMappingResponseFromJSON,
    ShowEntryColumnMappingResponseToJSON,
    StoreEntryColumnMappingRequestFromJSON,
    StoreEntryColumnMappingRequestToJSON,
    StoreEntryColumnMappingResponseFromJSON,
    StoreEntryColumnMappingResponseToJSON,
    StoreMultipleEntryColumnMappings200ResponseFromJSON,
    StoreMultipleEntryColumnMappings200ResponseToJSON,
    StoreMultipleEntryColumnMappingsRequestFromJSON,
    StoreMultipleEntryColumnMappingsRequestToJSON,
    UpdateEntryColumnMappingRequestFromJSON,
    UpdateEntryColumnMappingRequestToJSON,
    UpdateEntryColumnMappingResponseFromJSON,
    UpdateEntryColumnMappingResponseToJSON,
    UpdateMultipleEntryColumnMappings200ResponseFromJSON,
    UpdateMultipleEntryColumnMappings200ResponseToJSON,
    UpdateMultipleEntryColumnMappingsRequestFromJSON,
    UpdateMultipleEntryColumnMappingsRequestToJSON,
} from '../models';

export interface DestroyEntryColumnMappingRequest {
    id: number;
}

export interface ExportEntryColumnMappingsRequest {
    format: ExportEntryColumnMappingsFormatEnum;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterVersionId?: string;
    filterTitle?: string;
    filterSource?: string;
    filterMapped?: string;
    filterOperation?: string;
}

export interface IndexEntryColumnMappingsRequest {
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterVersionId?: string;
    filterTitle?: string;
    filterSource?: string;
    filterMapped?: string;
    filterOperation?: string;
}

export interface ShowEntryColumnMappingRequest {
    id: number;
    includes?: string;
}

export interface StoreEntryColumnMappingOperationRequest {
    storeEntryColumnMappingRequest: StoreEntryColumnMappingRequest;
}

export interface StoreMultipleEntryColumnMappingsOperationRequest {
    storeMultipleEntryColumnMappingsRequest: StoreMultipleEntryColumnMappingsRequest;
}

export interface UpdateEntryColumnMappingOperationRequest {
    id: number;
    updateEntryColumnMappingRequest: UpdateEntryColumnMappingRequest;
}

export interface UpdateMultipleEntryColumnMappingsOperationRequest {
    updateMultipleEntryColumnMappingsRequest: UpdateMultipleEntryColumnMappingsRequest;
}

/**
 * 
 */
export class EnumEntryColumnMappingsApi extends runtime.BaseAPI {

    /**
     * Delete entry column mapping.
     */
    async destroyEntryColumnMappingRaw(requestParameters: DestroyEntryColumnMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyEntryColumnMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete entry column mapping.
     */
    async destroyEntryColumnMapping(requestParameters: DestroyEntryColumnMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyEntryColumnMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export entry column mappings in a selected format (csv, json, parquet).
     */
    async exportEntryColumnMappingsRaw(requestParameters: ExportEntryColumnMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportEntryColumnMappings.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterVersionId !== undefined) {
            queryParameters['filter[version_id]'] = requestParameters.filterVersionId;
        }

        if (requestParameters.filterTitle !== undefined) {
            queryParameters['filter[title]'] = requestParameters.filterTitle;
        }

        if (requestParameters.filterSource !== undefined) {
            queryParameters['filter[source]'] = requestParameters.filterSource;
        }

        if (requestParameters.filterMapped !== undefined) {
            queryParameters['filter[mapped]'] = requestParameters.filterMapped;
        }

        if (requestParameters.filterOperation !== undefined) {
            queryParameters['filter[operation]'] = requestParameters.filterOperation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export entry column mappings in a selected format (csv, json, parquet).
     */
    async exportEntryColumnMappings(requestParameters: ExportEntryColumnMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportEntryColumnMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index entry column mappings.
     */
    async indexEntryColumnMappingsRaw(requestParameters: IndexEntryColumnMappingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexEntryColumnMappingsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterVersionId !== undefined) {
            queryParameters['filter[version_id]'] = requestParameters.filterVersionId;
        }

        if (requestParameters.filterTitle !== undefined) {
            queryParameters['filter[title]'] = requestParameters.filterTitle;
        }

        if (requestParameters.filterSource !== undefined) {
            queryParameters['filter[source]'] = requestParameters.filterSource;
        }

        if (requestParameters.filterMapped !== undefined) {
            queryParameters['filter[mapped]'] = requestParameters.filterMapped;
        }

        if (requestParameters.filterOperation !== undefined) {
            queryParameters['filter[operation]'] = requestParameters.filterOperation;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexEntryColumnMappingsResponseFromJSON(jsonValue));
    }

    /**
     * Index entry column mappings.
     */
    async indexEntryColumnMappings(requestParameters: IndexEntryColumnMappingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexEntryColumnMappingsResponse> {
        const response = await this.indexEntryColumnMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show entry column mapping by id.
     */
    async showEntryColumnMappingRaw(requestParameters: ShowEntryColumnMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowEntryColumnMappingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showEntryColumnMapping.');
        }

        const queryParameters: any = {};

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowEntryColumnMappingResponseFromJSON(jsonValue));
    }

    /**
     * Show entry column mapping by id.
     */
    async showEntryColumnMapping(requestParameters: ShowEntryColumnMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowEntryColumnMappingResponse> {
        const response = await this.showEntryColumnMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store entry column mapping.
     */
    async storeEntryColumnMappingRaw(requestParameters: StoreEntryColumnMappingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreEntryColumnMappingResponse>> {
        if (requestParameters.storeEntryColumnMappingRequest === null || requestParameters.storeEntryColumnMappingRequest === undefined) {
            throw new runtime.RequiredError('storeEntryColumnMappingRequest','Required parameter requestParameters.storeEntryColumnMappingRequest was null or undefined when calling storeEntryColumnMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreEntryColumnMappingRequestToJSON(requestParameters.storeEntryColumnMappingRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreEntryColumnMappingResponseFromJSON(jsonValue));
    }

    /**
     * Store entry column mapping.
     */
    async storeEntryColumnMapping(requestParameters: StoreEntryColumnMappingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreEntryColumnMappingResponse> {
        const response = await this.storeEntryColumnMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple entry column mappings.
     */
    async storeMultipleEntryColumnMappingsRaw(requestParameters: StoreMultipleEntryColumnMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleEntryColumnMappings200Response>> {
        if (requestParameters.storeMultipleEntryColumnMappingsRequest === null || requestParameters.storeMultipleEntryColumnMappingsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleEntryColumnMappingsRequest','Required parameter requestParameters.storeMultipleEntryColumnMappingsRequest was null or undefined when calling storeMultipleEntryColumnMappings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleEntryColumnMappingsRequestToJSON(requestParameters.storeMultipleEntryColumnMappingsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleEntryColumnMappings200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple entry column mappings.
     */
    async storeMultipleEntryColumnMappings(requestParameters: StoreMultipleEntryColumnMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleEntryColumnMappings200Response> {
        const response = await this.storeMultipleEntryColumnMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update entry column mapping.
     */
    async updateEntryColumnMappingRaw(requestParameters: UpdateEntryColumnMappingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateEntryColumnMappingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateEntryColumnMapping.');
        }

        if (requestParameters.updateEntryColumnMappingRequest === null || requestParameters.updateEntryColumnMappingRequest === undefined) {
            throw new runtime.RequiredError('updateEntryColumnMappingRequest','Required parameter requestParameters.updateEntryColumnMappingRequest was null or undefined when calling updateEntryColumnMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateEntryColumnMappingRequestToJSON(requestParameters.updateEntryColumnMappingRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateEntryColumnMappingResponseFromJSON(jsonValue));
    }

    /**
     * Update entry column mapping.
     */
    async updateEntryColumnMapping(requestParameters: UpdateEntryColumnMappingOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateEntryColumnMappingResponse> {
        const response = await this.updateEntryColumnMappingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple entry column mappings.
     */
    async updateMultipleEntryColumnMappingsRaw(requestParameters: UpdateMultipleEntryColumnMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleEntryColumnMappings200Response>> {
        if (requestParameters.updateMultipleEntryColumnMappingsRequest === null || requestParameters.updateMultipleEntryColumnMappingsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleEntryColumnMappingsRequest','Required parameter requestParameters.updateMultipleEntryColumnMappingsRequest was null or undefined when calling updateMultipleEntryColumnMappings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/surveys/entry-column-mappings/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleEntryColumnMappingsRequestToJSON(requestParameters.updateMultipleEntryColumnMappingsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleEntryColumnMappings200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple entry column mappings.
     */
    async updateMultipleEntryColumnMappings(requestParameters: UpdateMultipleEntryColumnMappingsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleEntryColumnMappings200Response> {
        const response = await this.updateMultipleEntryColumnMappingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportEntryColumnMappingsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportEntryColumnMappingsFormatEnum = typeof ExportEntryColumnMappingsFormatEnum[keyof typeof ExportEntryColumnMappingsFormatEnum];
