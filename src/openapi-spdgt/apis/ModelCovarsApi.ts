/* tslint:disable */
/* eslint-disable */
/**
 * count-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DestroyResponse,
  ExportIndexResponse,
  IndexCovarsResponse,
  ShowCovarResponse,
  StoreCovarRequest,
  StoreCovarResponse,
  StoreMultipleCovars200Response,
  StoreMultipleCovarsRequest,
  UpdateCovarRequest,
  UpdateCovarResponse,
  UpdateMultipleCovars200Response,
  UpdateMultipleCovarsRequest,
} from '../models';
import {
    DestroyResponseFromJSON,
    DestroyResponseToJSON,
    ExportIndexResponseFromJSON,
    ExportIndexResponseToJSON,
    IndexCovarsResponseFromJSON,
    IndexCovarsResponseToJSON,
    ShowCovarResponseFromJSON,
    ShowCovarResponseToJSON,
    StoreCovarRequestFromJSON,
    StoreCovarRequestToJSON,
    StoreCovarResponseFromJSON,
    StoreCovarResponseToJSON,
    StoreMultipleCovars200ResponseFromJSON,
    StoreMultipleCovars200ResponseToJSON,
    StoreMultipleCovarsRequestFromJSON,
    StoreMultipleCovarsRequestToJSON,
    UpdateCovarRequestFromJSON,
    UpdateCovarRequestToJSON,
    UpdateCovarResponseFromJSON,
    UpdateCovarResponseToJSON,
    UpdateMultipleCovars200ResponseFromJSON,
    UpdateMultipleCovars200ResponseToJSON,
    UpdateMultipleCovarsRequestFromJSON,
    UpdateMultipleCovarsRequestToJSON,
} from '../models';

export interface DestroyCovarRequest {
    id: number;
}

export interface ExportCovarsRequest {
    format: ExportCovarsFormatEnum;
    appends?: string;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterModelId?: string;
    filterSurveyTypeId?: string;
    filterType?: string;
    filterName?: string;
    filterDescription?: string;
    filterTransformation?: string;
    filterSortOrder?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface IndexCovarsRequest {
    appends?: string;
    includes?: string;
    pageSize?: number;
    pageNumber?: number;
    pageOmit?: number;
    sort?: string;
    filterId?: string;
    filterModelId?: string;
    filterSurveyTypeId?: string;
    filterType?: string;
    filterName?: string;
    filterDescription?: string;
    filterTransformation?: string;
    filterSortOrder?: string;
    filterCreatedAt?: string;
    filterUpdatedAt?: string;
}

export interface ShowCovarRequest {
    id: number;
    appends?: string;
    includes?: string;
}

export interface StoreCovarOperationRequest {
    storeCovarRequest: StoreCovarRequest;
}

export interface StoreMultipleCovarsOperationRequest {
    storeMultipleCovarsRequest: StoreMultipleCovarsRequest;
}

export interface UpdateCovarOperationRequest {
    id: number;
    updateCovarRequest: UpdateCovarRequest;
}

export interface UpdateMultipleCovarsOperationRequest {
    updateMultipleCovarsRequest: UpdateMultipleCovarsRequest;
}

/**
 * 
 */
export class ModelCovarsApi extends runtime.BaseAPI {

    /**
     * Delete covar.
     */
    async destroyCovarRaw(requestParameters: DestroyCovarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DestroyResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling destroyCovar.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DestroyResponseFromJSON(jsonValue));
    }

    /**
     * Delete covar.
     */
    async destroyCovar(requestParameters: DestroyCovarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DestroyResponse> {
        const response = await this.destroyCovarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export covars in a selected format (csv, json, parquet).
     */
    async exportCovarsRaw(requestParameters: ExportCovarsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExportIndexResponse>> {
        if (requestParameters.format === null || requestParameters.format === undefined) {
            throw new runtime.RequiredError('format','Required parameter requestParameters.format was null or undefined when calling exportCovars.');
        }

        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterModelId !== undefined) {
            queryParameters['filter[model_id]'] = requestParameters.filterModelId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterType !== undefined) {
            queryParameters['filter[type]'] = requestParameters.filterType;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterDescription !== undefined) {
            queryParameters['filter[description]'] = requestParameters.filterDescription;
        }

        if (requestParameters.filterTransformation !== undefined) {
            queryParameters['filter[transformation]'] = requestParameters.filterTransformation;
        }

        if (requestParameters.filterSortOrder !== undefined) {
            queryParameters['filter[sort_order]'] = requestParameters.filterSortOrder;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/export/{format}`.replace(`{${"format"}}`, encodeURIComponent(String(requestParameters.format))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportIndexResponseFromJSON(jsonValue));
    }

    /**
     * Export covars in a selected format (csv, json, parquet).
     */
    async exportCovars(requestParameters: ExportCovarsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExportIndexResponse> {
        const response = await this.exportCovarsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Index covars.
     */
    async indexCovarsRaw(requestParameters: IndexCovarsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexCovarsResponse>> {
        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page[size]'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['page[number]'] = requestParameters.pageNumber;
        }

        if (requestParameters.pageOmit !== undefined) {
            queryParameters['page[omit]'] = requestParameters.pageOmit;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        if (requestParameters.filterId !== undefined) {
            queryParameters['filter[id]'] = requestParameters.filterId;
        }

        if (requestParameters.filterModelId !== undefined) {
            queryParameters['filter[model_id]'] = requestParameters.filterModelId;
        }

        if (requestParameters.filterSurveyTypeId !== undefined) {
            queryParameters['filter[survey_type_id]'] = requestParameters.filterSurveyTypeId;
        }

        if (requestParameters.filterType !== undefined) {
            queryParameters['filter[type]'] = requestParameters.filterType;
        }

        if (requestParameters.filterName !== undefined) {
            queryParameters['filter[name]'] = requestParameters.filterName;
        }

        if (requestParameters.filterDescription !== undefined) {
            queryParameters['filter[description]'] = requestParameters.filterDescription;
        }

        if (requestParameters.filterTransformation !== undefined) {
            queryParameters['filter[transformation]'] = requestParameters.filterTransformation;
        }

        if (requestParameters.filterSortOrder !== undefined) {
            queryParameters['filter[sort_order]'] = requestParameters.filterSortOrder;
        }

        if (requestParameters.filterCreatedAt !== undefined) {
            queryParameters['filter[created_at]'] = requestParameters.filterCreatedAt;
        }

        if (requestParameters.filterUpdatedAt !== undefined) {
            queryParameters['filter[updated_at]'] = requestParameters.filterUpdatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexCovarsResponseFromJSON(jsonValue));
    }

    /**
     * Index covars.
     */
    async indexCovars(requestParameters: IndexCovarsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexCovarsResponse> {
        const response = await this.indexCovarsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Show covar by id.
     */
    async showCovarRaw(requestParameters: ShowCovarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ShowCovarResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling showCovar.');
        }

        const queryParameters: any = {};

        if (requestParameters.appends !== undefined) {
            queryParameters['appends'] = requestParameters.appends;
        }

        if (requestParameters.includes !== undefined) {
            queryParameters['includes'] = requestParameters.includes;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ShowCovarResponseFromJSON(jsonValue));
    }

    /**
     * Show covar by id.
     */
    async showCovar(requestParameters: ShowCovarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ShowCovarResponse> {
        const response = await this.showCovarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store covar.
     */
    async storeCovarRaw(requestParameters: StoreCovarOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreCovarResponse>> {
        if (requestParameters.storeCovarRequest === null || requestParameters.storeCovarRequest === undefined) {
            throw new runtime.RequiredError('storeCovarRequest','Required parameter requestParameters.storeCovarRequest was null or undefined when calling storeCovar.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreCovarRequestToJSON(requestParameters.storeCovarRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreCovarResponseFromJSON(jsonValue));
    }

    /**
     * Store covar.
     */
    async storeCovar(requestParameters: StoreCovarOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreCovarResponse> {
        const response = await this.storeCovarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Store multiple covars.
     */
    async storeMultipleCovarsRaw(requestParameters: StoreMultipleCovarsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoreMultipleCovars200Response>> {
        if (requestParameters.storeMultipleCovarsRequest === null || requestParameters.storeMultipleCovarsRequest === undefined) {
            throw new runtime.RequiredError('storeMultipleCovarsRequest','Required parameter requestParameters.storeMultipleCovarsRequest was null or undefined when calling storeMultipleCovars.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/multiple`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StoreMultipleCovarsRequestToJSON(requestParameters.storeMultipleCovarsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoreMultipleCovars200ResponseFromJSON(jsonValue));
    }

    /**
     * Store multiple covars.
     */
    async storeMultipleCovars(requestParameters: StoreMultipleCovarsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoreMultipleCovars200Response> {
        const response = await this.storeMultipleCovarsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update covar.
     */
    async updateCovarRaw(requestParameters: UpdateCovarOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateCovarResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateCovar.');
        }

        if (requestParameters.updateCovarRequest === null || requestParameters.updateCovarRequest === undefined) {
            throw new runtime.RequiredError('updateCovarRequest','Required parameter requestParameters.updateCovarRequest was null or undefined when calling updateCovar.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateCovarRequestToJSON(requestParameters.updateCovarRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateCovarResponseFromJSON(jsonValue));
    }

    /**
     * Update covar.
     */
    async updateCovar(requestParameters: UpdateCovarOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateCovarResponse> {
        const response = await this.updateCovarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update multiple covars.
     */
    async updateMultipleCovarsRaw(requestParameters: UpdateMultipleCovarsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateMultipleCovars200Response>> {
        if (requestParameters.updateMultipleCovarsRequest === null || requestParameters.updateMultipleCovarsRequest === undefined) {
            throw new runtime.RequiredError('updateMultipleCovarsRequest','Required parameter requestParameters.updateMultipleCovarsRequest was null or undefined when calling updateMultipleCovars.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/covars/multiple`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateMultipleCovarsRequestToJSON(requestParameters.updateMultipleCovarsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateMultipleCovars200ResponseFromJSON(jsonValue));
    }

    /**
     * Update multiple covars.
     */
    async updateMultipleCovars(requestParameters: UpdateMultipleCovarsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateMultipleCovars200Response> {
        const response = await this.updateMultipleCovarsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ExportCovarsFormatEnum = {
    Json: 'json',
    Csv: 'csv',
    Parquet: 'parquet'
} as const;
export type ExportCovarsFormatEnum = typeof ExportCovarsFormatEnum[keyof typeof ExportCovarsFormatEnum];
